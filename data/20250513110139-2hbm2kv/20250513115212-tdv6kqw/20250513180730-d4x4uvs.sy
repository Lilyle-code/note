{"ID":"20250513180730-d4x4uvs","Spec":"1","Type":"NodeDocument","Properties":{"id":"20250513180730-d4x4uvs","title":"2013-ICSE-Automatic Detection of Performance Deviations in the Load Testing of Large Scale Systems","type":"doc","updated":"20250513180826"},"Children":[{"ID":"20250513180743-tlslkau","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513180743-tlslkau","updated":"20250513180749"},"Children":[{"Type":"NodeText","Data":"摘要"}]},{"ID":"20250513180749-1bhiexv","Type":"NodeParagraph","Properties":{"id":"20250513180749-1bhiexv","updated":"20250513180749"},"Children":[{"Type":"NodeText","Data":"负载测试是评估大规模系统 （LSS） 性能的方法之一。在负载测试结束时，性能分析员  必须分析来自数百台受测计算机的数千个性能计数器。这些性能计数器是运行时系统属性（如 CPU 利用率、磁盘 I/O、内存消耗和网络流量）的度量。分析师观察计数器，以了解系统是否满足其服务级别协议 （SLA）。在本文中，我们提出并评估了一种监督式和三种无监督式方法，以帮助性能分析师 1） 更有效地比较负载测试，以检测可能导致 SLA 违规的性能偏差，以及 2） 为他们提供一组更小且可管理的重要性能计数器，以帮助对检测到的偏差进行根本原因分析。我们的案例研究基于从大型工业系统和开源基准测试应用程序获得的负载测试数据。案例研究表明，我们基于包装器的监督方法，它使用基于搜索的技术来查找性能计数器的最佳子集，并使用逻辑回归模型进行偏差预测，可以将性能计数器集减少多达 89%，同时检测出几乎没有误报的性能偏差（即 95% 的平均精度）。该研究还表明，有监督的方法比无监督的方法更稳定和有效，但由于其半自动化训练阶段，它的开销更大。"}]},{"ID":"20250513180743-iryjcnv","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513180743-iryjcnv","updated":"20250513180806"},"Children":[{"Type":"NodeText","Data":"Introduction"}]},{"ID":"20250513180743-6ngmj9t","Type":"NodeParagraph","Properties":{"id":"20250513180743-6ngmj9t","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"Large scale systems：由大量（成千上万台）运行复杂应用程序的机器组成。"}]},{"ID":"20250513180743-uvwpylr","Type":"NodeParagraph","Properties":{"id":"20250513180743-uvwpylr","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"LLS通过提供服务支持庞大的用户群 -"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003e"}]},{"Type":"NodeText","Data":" LLS的性能退化可能造成巨大的经济损失 -"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003e"}]},{"Type":"NodeText","Data":" 例如，PayPal中断一个小时可能造成720万美元的损失（Analyzing eBay platform strategies: An application of meyer's product platform strategy model）-"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003e"}]},{"Type":"NodeText","Data":"越早检测到性能问题越好"}]},{"ID":"20250513180743-h3ud2gj","Type":"NodeParagraph","Properties":{"id":"20250513180743-h3ud2gj","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"负载测试(load testing)：在高负载下对系统性能进行评估 -"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003e"}]},{"Type":"NodeText","Data":" 目前负载测试费时费力且容易出错 -"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003e"}]},{"Type":"NodeText","Data":" 现有的负载测试研究主要集中在负载测试集的自动生成上（Automated performance analysis of load tests） -"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003e"}]},{"Type":"NodeText","Data":" 目前关于如何高效分析LLS负载测试生成的TB级别数据的研究较少"}]},{"ID":"20250513180743-af656rs","Type":"NodeParagraph","Properties":{"id":"20250513180743-af656rs","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"负载测试中：通常一个或多个负载生成器模拟成千上万的并发事务 -"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003e"}]},{"Type":"NodeText","Data":" 监控被测程序，记录(非常大)的性能计数器数据 -"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003e"}]},{"Type":"NodeText","Data":" 性能计数器捕获系统的性能属性（运行时的CPU利用率，磁盘I/O，（消息）队列的使用和网络流量）-"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003e"}]},{"Type":"NodeText","Data":" 性能分析师通过与过去类似测试中已经记录的行为比较来判断待测系统在负载下的行为 -"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003e"}]},{"Type":"NodeText","Data":" 如果不存在过去记录的数据（例如对于一个新的组件、产品或一个主要的待测版本），性能分析师利用经验来决定预期的行为 (存在预期问题，是否能够使用MT)"}]},{"ID":"20250513180743-5uq63yi","Type":"NodeParagraph","Properties":{"id":"20250513180743-5uq63yi","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"在作者之前的工作引入了一种无监督方法实现负载测试自动化分析 (Automatic comparison of load tests to support the performance analysis of large enterprise systems) -"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003e"}]},{"Type":"NodeText","Data":" 本文中提出了一种用于同类型分析的有监督方法，以及两种额外的无监督方法作为比较基准-"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003e"}]},{"Type":"NodeText","Data":" 这4种方法都使用负载测试获得的性能计数器数据来构造性能特征(performance signatures) -"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003e"}]},{"Type":"NodeText","Data":" 这些特征是最小的性能计数器集合，用于描述给定负载测试的被测系统( SUT )的基本特征 (基本特征 ？"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"="}]},{"Type":"NodeText","Data":" 基本属性， 是否能够用来构造蜕变关系) -"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003e"}]},{"Type":"NodeText","Data":" 分析signatures的负载数据而不是整个数据有助于1 )有效地将负载测试与基线测试进行比较，以检测性能偏差，2 )为分析人员提供一组可管理的性能计数器，用于根本原因分析"}]},{"ID":"20250513180743-tmfdf3o","Type":"NodeParagraph","Properties":{"id":"20250513180743-tmfdf3o","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"本文贡献：(1) 提供了自动检测负载测试中的性能偏差方法（2）在工业界和开源环境下，通过实证评估和比较方法的有效性，表明可以达到高达95 %的平均精确率和94 %的平均召回率。"}]},{"ID":"20250513180743-kfke7wi","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513180743-kfke7wi","updated":"20250513180826"},"Children":[{"Type":"NodeText","Data":"负载测试的自动化分析"}]},{"ID":"20250513180743-huy09m0","Type":"NodeParagraph","Properties":{"id":"20250513180743-huy09m0","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"一个典型的负载测试包括（本文核心）："}]},{"ID":"20250513180743-d93zsrs","Type":"NodeParagraph","Properties":{"id":"20250513180743-d93zsrs","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"a )测试环境设置；"}]},{"ID":"20250513180743-c33o8e0","Type":"NodeParagraph","Properties":{"id":"20250513180743-c33o8e0","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"b )负载生成；"}]},{"ID":"20250513180743-z2w2g9k","Type":"NodeParagraph","Properties":{"id":"20250513180743-z2w2g9k","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"c )负载测试执行；"}]},{"ID":"20250513180743-9m4w9if","Type":"NodeParagraph","Properties":{"id":"20250513180743-9m4w9if","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"d )负载测试分析。"}]},{"ID":"20250513180743-2u8pxqv","Type":"NodeParagraph","Properties":{"id":"20250513180743-2u8pxqv","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"之后分析人员使用个人判断，结合专家和高级分析师的意见，来决定负载测试的结果是否偏离基线 (此部分可使用MR代替)。然而，要透彻分析性能计数器数据并及时控制性能问题，需要对子系统及其相关计数器有广泛的了解 -"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003e"}]},{"Type":"NodeText","Data":" 因此，提出和比较了性能偏差检测的自动化方法。这些方法可以帮助分析人员更有效地分析负载测试结果，并为他们提供一组较小且易于管理的重要性能计数器，以协助分析偏差的根本原因。"}]},{"ID":"20250513180743-oaxy6ty","Type":"NodeParagraph","Properties":{"id":"20250513180743-oaxy6ty","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513180743-ua0zbc2.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513180743-kg5z2kv","Type":"NodeParagraph","Properties":{"id":"20250513180743-kg5z2kv","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"本文的顶层方法（图1）将性能计数器数据减少为一个小的特征，并将负载测试的特征与其基线测试的特征进行比较。检查几个性能计数器要比检查测试过程中记录的整个(成百上千)组计数器容易得多。"}]},{"ID":"20250513180743-svjm5ws","Type":"NodeList","ListData":{},"Properties":{"id":"20250513180743-svjm5ws","updated":"20250513180743"},"Children":[{"ID":"20250513180743-slc9ibd","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-slc9ibd","updated":"20250513180743"},"Children":[{"ID":"20250513180743-yy50y3m","Type":"NodeParagraph","Properties":{"id":"20250513180743-yy50y3m","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"数据准备：性能偏差检测从准备负载测试和基线试验的性能数据开始。数据准备的主要原因之一是对\"缺失数据\"的处理。由于大规模系统的分布式特性，性能计数器数据可能会丢失一些数据或者包含空的计数器变量。当性能监视器由于带宽拥塞、系统冻结或I / O缓冲区溢出等原因未能记录性能计数器变量( e.g. % CPU利用率)的某些观测值时，会导致性能计数器数据缺失，需要去除空的计数器变量来净化性能计数器数据。对于缺失的性能计数器数据，采用列表删除的方式进行处理，即如果记录中缺失任何单个性能计数器值，则剔除整条记录。"}]}]},{"ID":"20250513180743-go55rya","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-go55rya","updated":"20250513180743"},"Children":[{"ID":"20250513180743-wvdzf4i","Type":"NodeParagraph","Properties":{"id":"20250513180743-wvdzf4i","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"性能特征生成：为了将数据集中到重要计数器，需要从基线测试的性能计数器列表中生成一个性能计数器特征，这可以看作是一个降维问题。接下来，从新的负载测试运行中提取出相似的计数器集合。如果不能从新的负载测试运行中提取一个性能计数器，而该性能计数器是基线负载测试特征的一部分，则从基线签名中消除相应的性能计数器。无法从新的负载测试中提取签名的原因包括："}]},{"ID":"20250513180743-6x1dsvp","Type":"NodeList","ListData":{},"Properties":{"id":"20250513180743-6x1dsvp","updated":"20250513180743"},"Children":[{"ID":"20250513180743-gm1rx0t","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-gm1rx0t","updated":"20250513180743"},"Children":[{"ID":"20250513180743-v8cf932","Type":"NodeParagraph","Properties":{"id":"20250513180743-v8cf932","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"a )在数据准备过程中删除计数器数据；"}]}]},{"ID":"20250513180743-mhiog7v","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-mhiog7v","updated":"20250513180743"},"Children":[{"ID":"20250513180743-gl5x130","Type":"NodeParagraph","Properties":{"id":"20250513180743-gl5x130","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"b )在测试(由于带宽饱和或网络问题而无法到达)的过程中，日志记录作为性能计数器资源的失败可能变得不可用；"}]}]},{"ID":"20250513180743-6k77osz","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-6k77osz","updated":"20250513180743"},"Children":[{"ID":"20250513180743-b1esu6v","Type":"NodeParagraph","Properties":{"id":"20250513180743-b1esu6v","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"c )监控代理无法在监测站启动线程对资源进行采样。"}]}]}]}]}]},{"ID":"20250513180743-a4dx401","Type":"NodeParagraph","Properties":{"id":"20250513180743-a4dx401","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"将当前负载测试的特征值 (所选性能计数器) 与基线测试数据进行比较（差分测试）。偏差被报告为异常，并将特征发送给调查，用来进行根本原因分析。"}]},{"ID":"20250513180743-gxdo5cd","Type":"NodeParagraph","Properties":{"id":"20250513180743-gxdo5cd","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513180743-0qt5q4s.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513180743-0iukn2t","Type":"NodeParagraph","Properties":{"id":"20250513180743-0iukn2t","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"表1总结了本文方法：本文使用两种基本的降维算法，随机和聚类，主要作为特征生成的比较基准。以及两种更先进的方法，一个有监督的( WRAPPER )和一个无监督的( PCA )，以探索改善基线的可能性。"}]},{"ID":"20250513180743-pudpzf8","Type":"NodeParagraph","Properties":{"id":"20250513180743-pudpzf8","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"PS：机器学习特征选择方法可以分为三类——Filter, Wrapper, Embedding。"}]},{"ID":"20250513180743-9klcvov","Type":"NodeList","ListData":{},"Properties":{"id":"20250513180743-9klcvov","updated":"20250513180743"},"Children":[{"ID":"20250513180743-tqrvtop","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-tqrvtop","updated":"20250513180743"},"Children":[{"ID":"20250513180743-wzv373r","Type":"NodeParagraph","Properties":{"id":"20250513180743-wzv373r","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"Filter：过滤式方法先对数据集进行特征选择，然后再训练模型，特征选择过程与后续模型训练无关。"}]}]},{"ID":"20250513180743-4wlxrt3","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-4wlxrt3","updated":"20250513180743"},"Children":[{"ID":"20250513180743-mqvw0uc","Type":"NodeParagraph","Properties":{"id":"20250513180743-mqvw0uc","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"Wrapper：直接把最终将要使用的模型的性能作为特征子集的评价标准，为给定的模型选择最有利于其性能的特征子集。"}]}]},{"ID":"20250513180743-2jpqx3g","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-2jpqx3g","updated":"20250513180743"},"Children":[{"ID":"20250513180743-n4wveja","Type":"NodeParagraph","Properties":{"id":"20250513180743-n4wveja","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"Embedding：将特征选择过程与学习器训练过程融为一体，两者在同一个优化过程中完成，即在学习器训练过程中自动地进行了特征选择。"}]}]},{"ID":"20250513180743-dhyn9bf","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-dhyn9bf","updated":"20250513180743"},"Children":[{"ID":"20250513180743-lphijca","Type":"NodeParagraph","Properties":{"id":"20250513180743-lphijca","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"Random Sampling Approach"}]},{"ID":"20250513180743-2qx4n2h","Type":"NodeList","ListData":{},"Properties":{"id":"20250513180743-2qx4n2h","updated":"20250513180743"},"Children":[{"ID":"20250513180743-rmy1kev","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-rmy1kev","updated":"20250513180743"},"Children":[{"ID":"20250513180743-jkbl1z3","Type":"NodeParagraph","Properties":{"id":"20250513180743-jkbl1z3","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"Motivation：该方法使用随机采样算法进行特征生成，并使用控制图进行性能偏差检测。这种方法背后的动机是使用最基本的基准来比较与我们其他提出的异常检测方法的性能。"}]}]},{"ID":"20250513180743-5slhbpb","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-5slhbpb","updated":"20250513180743"},"Children":[{"ID":"20250513180743-s1kgv3k","Type":"NodeParagraph","Properties":{"id":"20250513180743-s1kgv3k","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"Signature Generation：减少性能计数器和生成小签名的最简单的方法是从负载测试中记录的所有性能计数器的池中随机选择一些计数器。随机取样留给回答的唯一问题是选择的计数器个数。我们使用20个性能计数器来构造一个签名。这来自于我们与从业者(本行业合作伙伴的绩效分析师)的经验和他们\"首选\"的最大可管理签名大小。一般来说，这个最大尺寸取决于测试人员的偏好和系统的大小。我们也在稳定性分析部分(第四节)中更仔细地考虑了特征大小的影响。"}]}]},{"ID":"20250513180743-lvonkpp","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-lvonkpp","updated":"20250513180743"},"Children":[{"ID":"20250513180743-alfp4fs","Type":"NodeParagraph","Properties":{"id":"20250513180743-alfp4fs","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"Deviation Detection：该方法通过比较基于\"控制图\"的统计质量控制技术的性能特征来实现基线负载测试和新负载测试之间性能偏差的自动检测。控制图使用控制限来表示从一个过程中应该期望的变化范围。当一个过程在受控范围内时，任何变化都是正常的；而外部极限变化被认为是偏差。我们使用了控制图，因为它过去在分析负载测试方面是成功的。我们从基线负载测试为每个性能计数器生成控制图的控制限，如果一个负载测试的计数器有任何观测值违反了控制限，则该试验被标记为偏离。对于给定的性能计数器，控制图的中心极限( Central Limit，CL )是性能计数器在基线测试中所有值的中位数。上/下控制限( U / LCL )为系统正常工作时计数器量程的上/下限值。使用控制图检测性能违规的常用选择是使用第10和第90百分位数来识别LCL和UCL。违背率是性能违背在整个数据点上所占的百分比，它被用作偏差检测的阈值。让我们用一个例子来说明使用控制图进行偏差检测。图2给出了一个基准负载测试的性能计数器\" A \"有11个实例的例子\u003c11,10,5,6,7,8,6,10,13,9,3\u003e。基线的LCL (第10百分位数)、CL (中位数)和UCL (第90百分位数)分别为4、8和12。新负载测试计数器的值为\u003c2,3,6,7,4,14,10,9,1,13,4\u003e。违例是大于基线的UCL ( 12 )或小于其LCL ( 4 )的负载测试值。因此，在本算例中，新负载测试的违规比例为6 / 11 = 54 %。值得注意的是，阈值的设置要高于基线负荷试验本身的违反率( 2 / 11 = 18 % )。例如，假设以20 %为阈值，则新负载测试标记为偏离。"}]}]}]}]}]},{"ID":"20250513180743-tfwpx7o","Type":"NodeParagraph","Properties":{"id":"20250513180743-tfwpx7o","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513180743-a54aqgd.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513180743-ie0fvcy","Type":"NodeList","ListData":{},"Properties":{"id":"20250513180743-ie0fvcy","updated":"20250513180743"},"Children":[{"ID":"20250513180743-7h5ngyz","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-7h5ngyz","updated":"20250513180743"},"Children":[{"ID":"20250513180743-teeunqp","Type":"NodeParagraph","Properties":{"id":"20250513180743-teeunqp","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"Clustering (K-Means) Approach"}]},{"ID":"20250513180743-wh8kmmi","Type":"NodeList","ListData":{},"Properties":{"id":"20250513180743-wh8kmmi","updated":"20250513180743"},"Children":[{"ID":"20250513180743-fgg9yke","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-fgg9yke","updated":"20250513180743"},"Children":[{"ID":"20250513180743-dbzc6fl","Type":"NodeParagraph","Properties":{"id":"20250513180743-dbzc6fl","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"Motivation：负载测试的性能计数器数据是高度相关的。有许多计数器本质上衡量的是一个共同的性能特征。例如，\"处理器时间\"、\"处理器总时间\"和\"处理器总特权时间\"等计数器基本上是衡量处理器利用率的。去除相关参数(在我们的案例中,性能计数器)最常用的方法之一是聚类。使用聚类算法，可以根据相似性度量对性能计数器进行分组，使得高度相似的计数器位于相同的组中。然后，为了降低数据的维度并生成一个小的特征，可以在每个组中选择一个具有代表性的计数器。"}]}]},{"ID":"20250513180743-026t5ud","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-026t5ud","updated":"20250513180743"},"Children":[{"ID":"20250513180743-ld0vxye","Type":"NodeParagraph","Properties":{"id":"20250513180743-ld0vxye","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"Signature Generation：我们的方法中使用的聚类算法是著名的K - Means。 K - Means聚类以n个性能计数器和k个聚类数作为输入，每个性能计数器由其针对不同数据项的值的向量表示。该聚类算法将计数器分组为k个簇，其目标是最小化误差平方和，即每个向量与该簇质心的欧氏距离的平方和。然后，基线负载测试的特征由代表性计数器(每个簇的质心)组成。"}]}]},{"ID":"20250513180743-9xzqiym","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-9xzqiym","updated":"20250513180743"},"Children":[{"ID":"20250513180743-qhhqns9","Type":"NodeParagraph","Properties":{"id":"20250513180743-qhhqns9","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"Deviation Detection：该方法使用与随机抽样方法相同的控制图。"}]}]}]}]},{"ID":"20250513180743-v9axjx5","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-v9axjx5","updated":"20250513180743"},"Children":[{"ID":"20250513180743-8s1oba3","Type":"NodeParagraph","Properties":{"id":"20250513180743-8s1oba3","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"PCA Approach"}]}]},{"ID":"20250513180743-mqfq2vm","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-mqfq2vm","updated":"20250513180743"},"Children":[{"ID":"20250513180743-n9enn5x","Type":"NodeParagraph","Properties":{"id":"20250513180743-n9enn5x","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"Motivation：主成分分析( PCA )用作比聚类更先进的技术，以减少性能计数器的数量。在本文中使用PCA的目标与聚类相同：选择相关性最小的性能计数器子集，仍然可以解释数据中的最大变化。PCA的主要目标是通过将数据集投影到低维空间来降低原始数据的维数。为此，PCA使用新的变量来重新表达数据，这些变量是原始变量的线性组合。新的变量被称为主成分( PCs )，顶端的成分能够像整个变量集一样解释数据中的变化。此外，新的成分具有更低的共线性。因此，可以只选择少数顶端成分，对数据进行降维处理。关于PCA的更多细节，它的详细实现，以及在变量缩减方面的应用可以在[ 4 ]中找到。在之前的工作中，我们使用PCA对性能数据进行降维。因此，在本文中，我们在更大的环境和更多的情况下重新应用这种方法。我们还将PCA方法与本文新引入的其他方法进行了比较。"}]}]},{"ID":"20250513180743-wvbkdqw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-wvbkdqw","updated":"20250513180743"},"Children":[{"ID":"20250513180743-4hd2v00","Type":"NodeParagraph","Properties":{"id":"20250513180743-4hd2v00","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"Data Preparation：性能计数器有不同的数值范围，导致不同的方差。PCA识别那些具有大数据分布的变量，而忽略那些具有低方差的变量。为了消除PCA对方差较大的变量的偏倚，我们通过单位方差缩放( Unit Variance Scaling )对性能计数器进行标准化，即把每个计数器变量的观测值除以变量的标准差[ 6 ]。因此，经过标准化后，每个性能计数器变量的方差等于1.0。"}]}]}]},{"ID":"20250513180743-9mvi9s0","Type":"NodeParagraph","Properties":{"id":"20250513180743-9mvi9s0","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513180743-5lbui6d.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513180743-si0gqd2","Type":"NodeParagraph","Properties":{"id":"20250513180743-si0gqd2","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513180743-9qeynsx.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513180743-8mdfoqp","Type":"NodeList","ListData":{},"Properties":{"id":"20250513180743-8mdfoqp","updated":"20250513180743"},"Children":[{"ID":"20250513180743-ynawoba","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-ynawoba","updated":"20250513180743"},"Children":[{"ID":"20250513180743-t4n2no3","Type":"NodeParagraph","Properties":{"id":"20250513180743-t4n2no3","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"Signature Generation：用一个例子来说明特征生成阶段。假设我们有18个性能计数器，我们想从这些计数器中生成一个特征 (随着尺寸的减小)。TABLE II展示了将PCA应用于我们的例子性能计数器数据的部分结果。PCA将18个计数器投影到12个PC上。特征值衡量的是每个PC对数据集中变化的解释程度。例如，PC1占整个性能计数器数据集变异性的11.431 / 18 "},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"*"}]},{"Type":"NodeText","Data":" 100 "},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"="}]},{"Type":"NodeText","Data":" 63.60 %。为了减少变量的数量，我们需要决定在12台PC机中捕获性能计数器数据变异性的最小数( top x )。确定前x个PC是一个具有挑战性的问题。在本文中，我们使用\" % Cumulative Variability \"来选择top x [ 9 ]。根据文献[ 6 ]，使用90 %的累积变异率足以解释大部分数据，并且信息损失最小。因此，我们提取了TABLE II中显示的前四个PC。现在，负载测试数据可以用相对较少的PC机(本例中的4个PC ,而不是原来的12个PC或18个原始计数器)来表示。在降低性能计数器数据集的维度后，我们对排名靠前的x个PC进行分解，即在上述PC1到PC4的例子中，采用了特征向量分解技术[ 6 ]。我们对PC进行分解，将其映射回性能计数器（性能分析师对性能计数器而不是主成分感兴趣)。每个性能计数器根据其与某个组件的关联关系，被赋予0 "},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"~"}]},{"Type":"NodeText","Data":" 1之间的权重。性能计数器与PC机的关联反映了计数器给PC机增加的变化量(性能计数器的重量越大，对PC的贡献就越大)。我们利用这些权重从排名前x的组件中选择重要的性能计数器来构造性能特征。为了从前x个分量中选择重要的计数器，我们保留了\"权重\"作为可调参数。降低\"权重\"参数的值将导致更多的性能计数器从PC机中选择，从而产生一个大的特征。在这个例子中，我们设置了一个较低的\"权重\"参数"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"="}]},{"Type":"NodeText","Data":" 0.2，以产生前7个计数器。将参数调至0.4和0.6，得到6个和5个计数器的结果TABLE III显示了18个性能计数器中的7个，这些性能计数器根据其权重进行选择和排序。这七个计数器捕获了各自负载测试的最重要特征，并作为其性能特征。"}]}]},{"ID":"20250513180743-inc34x9","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-inc34x9","updated":"20250513180743"},"Children":[{"ID":"20250513180743-rpt1q1t","Type":"NodeParagraph","Properties":{"id":"20250513180743-rpt1q1t","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"Deviation Detection：从基线负载测试的性能计数器数据中自动创建性能特征后，我们的方法从\"新测试\"中提取相同的性能计数器集合。接下来，该方法对两组签名进行比较。比较是基于性能计数器权重的。如果基线签名的性能计数器权重与\"新负载测试\"不同，这种权重的不匹配意味着两种负载测试中性能计数器值的实际分布( s )不同。因此，该方法将新的载荷试验标记为偏离。我们先前的研究[ 10 ]表明，PCA作为一种基于方差的算法，至少需要40个性能计数器值的观测值来创建性能签名。因此，我们的PCA方法的有效性取决于性能分析师设置的采样间隔。例如，通过每分钟收集性能计数器样本(观测值)，我们的方法能够在40分钟后检测到性能偏差(如果有发生)。然而，如果将采样间隔设置为每5秒，则在3.5分钟的时间范围内检测到性能偏差。"}]}]},{"ID":"20250513180743-3w2rbr1","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-3w2rbr1","updated":"20250513180743"},"Children":[{"ID":"20250513180743-ois5vl3","Type":"NodeParagraph","Properties":{"id":"20250513180743-ois5vl3","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"WRAPPER Approach"}]},{"ID":"20250513180743-78873bh","Type":"NodeList","ListData":{},"Properties":{"id":"20250513180743-78873bh","updated":"20250513180743"},"Children":[{"ID":"20250513180743-mzgpazx","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-mzgpazx","updated":"20250513180743"},"Children":[{"ID":"20250513180743-uql8r07","Type":"NodeParagraph","Properties":{"id":"20250513180743-uql8r07","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"Motivation：随机、聚类和PCA方法都是无监督方法。为了进行更深入的实证研究，我们引入了WRAPPER方法。它需要性能分析师在数据准备阶段的干预，因此是有监督的，可以被认为是一种半自动化的方法。"}]}]},{"ID":"20250513180743-ih8cong","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-ih8cong","updated":"20250513180743"},"Children":[{"ID":"20250513180743-xzhjlzj","Type":"NodeParagraph","Properties":{"id":"20250513180743-xzhjlzj","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"Data Preparation：与无监督方法类似，有监督方法的性能计数器数据需要从缺失和空的性能计数器变量中净化。此外，对于有监督的方法，基线负载测试的性能计数器数据需要分别标记为每个正常和异常观测的通过或失败。这些数据有望由负载测试人员/性能分析员根据他们的经验和先前的负载测试结果进行一次标注。因此，标记一次完成，然后多次使用。值得注意的是，基线测试和新测试都应该在数据准备阶段进行净化。然而，只有基线测试需要人工标注一次。"}]}]}]}]}]},{"ID":"20250513180743-xrsqy9f","Type":"NodeParagraph","Properties":{"id":"20250513180743-xrsqy9f","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513180743-uhnwmbq.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513180743-9rro45l","Type":"NodeList","ListData":{},"Properties":{"id":"20250513180743-9rro45l","updated":"20250513180743"},"Children":[{"ID":"20250513180743-69o6vik","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-69o6vik","updated":"20250513180743"},"Children":[{"ID":"20250513180743-cymnrwe","Type":"NodeParagraph","Properties":{"id":"20250513180743-cymnrwe","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"Signature Generation：在该方法中，我们使用了一种基于Wrapper的属性选择技术[ 11 ]用于签名生成( WRAPPER )。本文的WRAPPER方法首次尝试将属性选择应用于大规模系统的性能计数器上。在该技术中，通常使用搜索算法(例如,贪心或遗传搜索算法)来优化属性子集的选择，以提高其预测的准确性。子集的准确性由一个预测模型来衡量，例如，OneR，决策树或回归模型。在本文中，我们使用了一个非常基本的基于包装器的属性选择( OneR -基因搜索)。选择One-R作为最基本的预测模型，我们使用在Weka中实现的遗传搜索来最大限度地提高子集的预测精度。遗传搜索的适应度函数基本上是由所选属性所做的OneR模型的准确性。为了保持我们的WRAPPER方法作为最基本的监督方法，我们没有对遗传搜索的参数进行调整。我们简单地复用了Weka的推荐值(交叉概率"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"="}]},{"Type":"NodeText","Data":" 0.6 ,变异概率"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"="}]},{"Type":"NodeText","Data":" 0.033 ,最大代数"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"="}]},{"Type":"NodeText","Data":" 20 ,种群规模"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"="}]},{"Type":"NodeText","Data":" 20)。属性选择通过标准的10折交叉验证过程进行验证，该过程首先将输入的性能计数器数据划分为10折。包装器选择算法每次取一个分区( fold )作为测试集，在剩余的9个分区上进行训练。然后，我们选择了前k个性能计数器，这些计数器在10倍中被选择的最多。这些前k个计数器形成相应负载测试的性能特征。每个性能计数器变量的频率是根据其在折叠中出现的次数除以总的折叠数来计算的。选择前k个基于两个启发式中的一个：' % Frequency '，即性能计数器在10倍内被选中的最小次数百分比，或' Count '，即所需计数器的确切数量。TABLE IV展示了我们对第二节中使用的相同性能计数器数据的监督签名生成的结果。在表IV中，我们展示了两个签名：a )指定Count "},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"="}]},{"Type":"NodeText","Data":" 5，得到一个由性能计数器1、2、5、7和8组成的特征；b )指定频率% Frequency "},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003e"}]},{"Type":"NodeText","Data":" 20，得到10个性能计数器中至少出现3次的性能计数器，即性能计数器1、2、5、6、7和8。在PCA方法中，通过设置权重参数为0.2，选择% Frequency "},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003e"}]},{"Type":"NodeText","Data":" 20与前k个性能计数器选择的80 %保持一致。"}]}]},{"ID":"20250513180743-l9b99pm","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-l9b99pm","updated":"20250513180743"},"Children":[{"ID":"20250513180743-suuzkxr","Type":"NodeParagraph","Properties":{"id":"20250513180743-suuzkxr","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"Deviation Detection：在该阶段，从基线负载测试中提取特征性能计数器的观测值。然后将提取的数据送入逻辑回归[ 13 ]，作为训练集，构建分类模型进行性能异常检测。最后，使用回归模型将新负载测试的特征观测值分类为通过或失败。"}]}]}]},{"ID":"20250513180743-djvccf7","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513180743-djvccf7","updated":"20250513180807"},"Children":[{"Type":"NodeText","Data":"CASE STUDY"}]},{"ID":"20250513180743-2g634s7","Type":"NodeParagraph","Properties":{"id":"20250513180743-2g634s7","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"RQ. 本文基于特征码的方法在负载测试中检测性能偏差的有效性如何?"}]},{"ID":"20250513180743-q4sl1v9","Type":"NodeParagraph","Properties":{"id":"20250513180743-q4sl1v9","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"Motivation：低召回率的方法在实际中不会被采用，因为它不能检测到许多已经存在的偏差。产生高召回率和低精确度结果的方法也是不有用的，因为它使性能分析师淹没了太多的误报。理想的方法应该预测出一组最小且正确的性能偏差。我们使用精确率、召回率和F-测量来评估我们的方法的性能。"}]},{"ID":"20250513180743-r7sek9u","Type":"NodeList","ListData":{},"Properties":{"id":"20250513180743-r7sek9u","updated":"20250513180743"},"Children":[{"ID":"20250513180743-qfryhg9","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-qfryhg9","updated":"20250513180743"},"Children":[{"ID":"20250513180743-jqnc55f","Type":"NodeParagraph","Properties":{"id":"20250513180743-jqnc55f","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"研究对象与环境设置"}]}]}]},{"ID":"20250513180743-9gb1efs","Type":"NodeParagraph","Properties":{"id":"20250513180743-9gb1efs","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513180743-g7zfwgj.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513180743-4qexqq7","Type":"NodeParagraph","Properties":{"id":"20250513180743-4qexqq7","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"我们获得了它们的子系统的两组负载测试计数器数据："}]},{"ID":"20250513180743-ak1874g","Type":"NodeList","ListData":{},"Properties":{"id":"20250513180743-ak1874g","updated":"20250513180743"},"Children":[{"ID":"20250513180743-5dnv2nd","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-5dnv2nd","updated":"20250513180743"},"Children":[{"ID":"20250513180743-dnjanea","Type":"NodeParagraph","Properties":{"id":"20250513180743-dnjanea","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"生产数据：从所研究的工业系统的性能库中获得。负载测试由公司专家进行。"}]}]},{"ID":"20250513180743-ows27ou","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-ows27ou","updated":"20250513180743"},"Children":[{"ID":"20250513180743-gs4q49f","Type":"NodeParagraph","Properties":{"id":"20250513180743-gs4q49f","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"测试床数据：使用公司的testbed进行负载测试期间获得。"}]}]},{"ID":"20250513180743-4mc0wq3","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-4mc0wq3","updated":"20250513180743"},"Children":[{"ID":"20250513180743-5du9yd2","Type":"NodeParagraph","Properties":{"id":"20250513180743-5du9yd2","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"故障注入"}]}]}]},{"ID":"20250513180743-4g4ztlf","Type":"NodeParagraph","Properties":{"id":"20250513180743-4g4ztlf","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513180743-em75gcw.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513180743-unqpmq6","Type":"NodeParagraph","Properties":{"id":"20250513180743-unqpmq6","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"为了研究我们对现实情形的方法，我们必须在存在代表性错误的情况下对它们进行评估。要做到这一点，我们首先需要选择故障的类别，例如软件故障，硬件故障和操作员/人为失误。其次，我们需要确定每个类别的故障触发因素，例如，软件故障可能是由资源耗尽、逻辑错误或系统过载引发的。Pretet [ 14 ]对企业Web服务系统中的故障进行了详细的研究，并得出结论，80 %的故障是由于软件故障和人为失误造成的。因此，在本文中，我们使用这些类别进行实验。Pretet还列出了软件故障和人为失误故障最常见的七种触发因素。其中，我们使用了4种适合负载测试实验的失效触发器，如表6所示。下面，我们解释为什么我们选择表VI中列出的故障触发器以及它们与负载测试的关系。"}]},{"ID":"20250513180743-qn1bylt","Type":"NodeList","ListData":{},"Properties":{"id":"20250513180743-qn1bylt","updated":"20250513180743"},"Children":[{"ID":"20250513180743-3z2qmes","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-3z2qmes","updated":"20250513180743"},"Children":[{"ID":"20250513180743-3z00fmn","Type":"NodeParagraph","Properties":{"id":"20250513180743-3z00fmn","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"Resource Exhaustion：大型企业将资源枯竭列为最基本的领域问题之一[ 15 ]。研究人员还发现，部署后的问题很少是由于功能错误引起的，相反，它们通常是由于资源饱和问题导致应用程序响应不够快，崩溃或在重负载下挂起。(功能与性能)"}]}]},{"ID":"20250513180743-ij0wj0q","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-ij0wj0q","updated":"20250513180743"},"Children":[{"ID":"20250513180743-p3i7vtk","Type":"NodeParagraph","Properties":{"id":"20250513180743-p3i7vtk","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"System Overload：性能分析人员通常需要在特定的硬件和软件条件下，针对特定的工作负载，对每个应用程序的发布或构建进行大量的测试[ 3 ]。他们必须仔细分析测试，以确保系统不超载，并满足其期望的SLA，例如响应时间或延迟。"}]}]},{"ID":"20250513180743-gj47put","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-gj47put","updated":"20250513180743"},"Children":[{"ID":"20250513180743-8e441qj","Type":"NodeParagraph","Properties":{"id":"20250513180743-8e441qj","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"Configuration Errors：负载测试失败最常见的原因之一是被测应用程序或其执行环境的错误配置。例如，数据库、Web服务器或负载生成器可能由于时间压力或复杂配置而被错误配置。"}]}]},{"ID":"20250513180743-twpbcbk","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-twpbcbk","updated":"20250513180743"},"Children":[{"ID":"20250513180743-wbloso1","Type":"NodeParagraph","Properties":{"id":"20250513180743-wbloso1","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"Procedural Errors：程序性错误是操作者错误类别中的第二个主要失败来源[ 14 ]。当分析员/测试人员没有按照指导原则和流程进行负载测试时，负载测试程序性错误就会发生。例如，在负载测试开始之前，测试人员忘记重新启动Web服务或初始化数据库表。类似地，在大规模系统中触发过程性错误的最常见原因之一是当测试人员在负载测试过程中忘记抑制/改变背景干扰负载的调度，例如杀毒软件的启动或数据库复制[ 16 ]。"}]}]},{"ID":"20250513180743-nm9ti9x","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-nm9ti9x","updated":"20250513180743"},"Children":[{"ID":"20250513180743-ha2u6de","Type":"NodeParagraph","Properties":{"id":"20250513180743-ha2u6de","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"Experiment Design"}]}]}]},{"ID":"20250513180743-x0kj6xm","Type":"NodeParagraph","Properties":{"id":"20250513180743-x0kj6xm","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"我们设计了七个实验来回答我们的研究问题。我们使用Thakkar (A framework for measurement based performance modeling) 的框架来自动化负载测试，并确保在整个实验过程中环境保持不变。"}]},{"ID":"20250513180743-49qdbd2","Type":"NodeParagraph","Properties":{"id":"20250513180743-49qdbd2","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"除实验7由从工业合作伙伴获得的生产数据组成外，其他所有负载测试实验均重复10次，以确保研究结果的一致性。爬坡和下倾斜、(升温和降温)时段被排除在载荷试验分析之外，因为系统通常在这些时段不稳定。我们使用Windows工具每隔10秒(采样间隔)后定期收集性能数据。这意味着，在试验台上进行的每一个工业试验都有2880个观测值，因为这些试验持续了8小时。然而，在DS2基准程序上进行的所有实验都是一个小时的测试，包含360个每个性能计数器观测次数。我们现在详细介绍了TABLE VI中所列故障的每次实验设置。"}]},{"ID":"20250513180743-91ast64","Type":"NodeList","ListData":{},"Properties":{"id":"20250513180743-91ast64","updated":"20250513180743"},"Children":[{"ID":"20250513180743-cp87u37","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-cp87u37","updated":"20250513180743"},"Children":[{"ID":"20250513180743-jwofgnd","Type":"NodeParagraph","Properties":{"id":"20250513180743-jwofgnd","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"实验1 ( CPU压力)：实验1通过触发资源耗尽来考察软件故障类别。对于实验1，我们进行了基线工作负荷的负载测试。然后使用CPU压力工具win Throttle "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"现有的压力测试工具","TextMarkTextContent":" 17 "},{"Type":"NodeText","Data":"来减缓Web服务器的CPU。我们选择winThrottle而不是其他的CPU压力工具，因为它是一个开源工具，可以使用系统硬件中的特性直接修改CPU的时钟速度，而不是使用软件的\"延迟循环\"或\" HLT指令\"来减慢机器的速度。"}]}]},{"ID":"20250513180743-6wi5h9c","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-6wi5h9c","updated":"20250513180743"},"Children":[{"ID":"20250513180743-lgzwvxs","Type":"NodeParagraph","Properties":{"id":"20250513180743-lgzwvxs","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"实验2 ( Memory Stress )：对于实验2，我们进行了与基线负载测试相同的负载测试，但是使用一个定制的开源内存压力工具Eat Mem [ 18 ] (其他内存压力测试工具) 向web服务器注入了一个内存bug。该工具在重复出现的时间间隔内分配随机数量的可用内存，以模拟内存泄漏。"}]}]},{"ID":"20250513180743-hzvt6td","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-hzvt6td","updated":"20250513180743"},"Children":[{"ID":"20250513180743-gnt78jx","Type":"NodeParagraph","Properties":{"id":"20250513180743-gnt78jx","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"实验3 (非正常工作负荷)：本实验采用DS2系统进行。我们触发了一个系统过载，这是Pretet [ 14 ]识别的第二个常见故障触发。本实验保持工作负载组合不变，将我们的工作负载执行率提高到4X，是基线配置的4倍。"}]}]},{"ID":"20250513180743-lek8lbf","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-lek8lbf","updated":"20250513180743"},"Children":[{"ID":"20250513180743-nprbyco","Type":"NodeParagraph","Properties":{"id":"20250513180743-nprbyco","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"实验4 (错误配置的负载生成器)：本实验使用测试平台模拟负载发生器配置错误导致的问题。因此，我们配置负载生成器来推送与基准负载不同的工作负载组合。"}]}]},{"ID":"20250513180743-8qhxjqq","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-8qhxjqq","updated":"20250513180743"},"Children":[{"ID":"20250513180743-sou5brs","Type":"NodeParagraph","Properties":{"id":"20250513180743-sou5brs","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"实验5 (干扰工作负荷)：本实验旨在引发负荷测试的程序性错误。我们创建了一个干扰背景工作负载故障，测试人员忘记重新安排与负载测试时间冲突的防病毒扫描。我们在一个小时的过程中，每隔10分钟用杀毒软件扫描一台Web服务器机器3分钟，以干扰主要的工作负载。"}]}]},{"ID":"20250513180743-hzm9hzn","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-hzm9hzn","updated":"20250513180743"},"Children":[{"ID":"20250513180743-b9awbmj","Type":"NodeParagraph","Properties":{"id":"20250513180743-b9awbmj","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"实验6 (非计划性复制)：本实验也旨在引发一个程序错误进行负荷测试。我们模拟了在负载测试过程中，测试人员忘记重新调度数据库复制的场景。设置复现时间与载荷试验的起止时间重合。"}]}]},{"ID":"20250513180743-ox6xsid","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-ox6xsid","updated":"20250513180743"},"Children":[{"ID":"20250513180743-wbw89m3","Type":"NodeParagraph","Properties":{"id":"20250513180743-wbw89m3","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"实验7 (生产数据)：本实验是在生产数据上进行的。性能分析师给了我们两组性能计数器数据：基线和偏离负载测试，但没有揭示故障类型。"}]}]},{"ID":"20250513180743-hym7otv","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-hym7otv","updated":"20250513180743"},"Children":[{"ID":"20250513180743-ghcin94","Type":"NodeParagraph","Properties":{"id":"20250513180743-ghcin94","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"衡量方法的有效性"}]}]}]},{"ID":"20250513180743-ukydn92","Type":"NodeParagraph","Properties":{"id":"20250513180743-ukydn92","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"为了评估我们的方法的有效性，我们使用了以下措施：精确率( Precision )、召回率( Recall )和F - Measure。精度是两次负荷试验正确检测到的性能偏差与预测的性能偏差之间的比值。召回率被定义为正确检测到的性能偏差数量与负载测试的实际性能偏差数量之间的比值。F-measure被定义为精确率和召回率的调和手段。"}]},{"ID":"20250513180743-plkck29","Type":"NodeParagraph","Properties":{"id":"20250513180743-plkck29","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513180743-5v9nw2d.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513180743-kkkp1nh","Type":"NodeParagraph","Properties":{"id":"20250513180743-kkkp1nh","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"alpha (α)的取值范围在0到无穷之间，以赋予召回率和精确率不同的权重。例如，在本文中，为了表明查全率和查准率一样重要，alpha的值为1.0。这些定义直接应用于控制图(随机和聚类方法)和逻辑回归( WRAPPER方法)的输出，其中分类是根据观测值(也就是说,对于每一个观察,都可以定义预测是真的还是假的)进行的。然而，PCA方法无法预测单个观测的性能偏差。由于如前所述，PCA需要一定的最小观测数来构造性能特征[ 16 ]。"}]},{"ID":"20250513180743-q3vx0zj","Type":"NodeParagraph","Properties":{"id":"20250513180743-q3vx0zj","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"因此，在利用PCA方法进行负荷试验分析的过程中，我们将负荷试验划分为时间区间。图3展示了两次负载测试的性能计数器数据。每次负载测试的性能计数器数据被划分为从t1到t10的等时间间隔。对于载荷试验- 2，在时间间隔t3，t4和t5注入一个失效。"}]},{"ID":"20250513180743-222s0a4","Type":"NodeParagraph","Properties":{"id":"20250513180743-222s0a4","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513180743-9onkku4.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513180743-8w5c7hg","Type":"NodeList","ListData":{},"Properties":{"id":"20250513180743-8w5c7hg","updated":"20250513180743"},"Children":[{"ID":"20250513180743-o9t283c","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180743-o9t283c","updated":"20250513180743"},"Children":[{"ID":"20250513180743-yirhvok","Type":"NodeParagraph","Properties":{"id":"20250513180743-yirhvok","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"案例研究结果"}]}]}]},{"ID":"20250513180743-5olkaf8","Type":"NodeParagraph","Properties":{"id":"20250513180743-5olkaf8","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"RQ1 基于特征方法在检测负载测试中的性能偏差方面有多有效?"}]},{"ID":"20250513180743-l98jb3j","Type":"NodeParagraph","Properties":{"id":"20250513180743-l98jb3j","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"表VIII报告了4种方法( Random : R , Clustering : C , PCA : P , WRAPPER : W)对所有7个实验的精确率、召回率和F-测量(对于前6个实验,其值是每个实验10次运行的平均值)的结果。TABLE VIII中的\" Total Counter \"列显示了为相应实验收集的性能计数器的总数。"}]},{"ID":"20250513180743-zbhbnvk","Type":"NodeParagraph","Properties":{"id":"20250513180743-zbhbnvk","updated":"20250513180743"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513180743-sghhckx.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]}]}