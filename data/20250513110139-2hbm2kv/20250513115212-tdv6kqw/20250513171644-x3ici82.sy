{"ID":"20250513171644-x3ici82","Spec":"1","Type":"NodeDocument","Properties":{"id":"20250513171644-x3ici82","title":"2020-ASE-PerfCI: A Toolchain for Automated Performance Testing during Continuous Integration of Python Projects","type":"doc","updated":"20250513171758"},"Children":[{"ID":"20250513171703-8vi4ibs","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513171703-8vi4ibs","updated":"20250513171704"},"Children":[{"Type":"NodeText","Data":"摘要"}]},{"ID":"20250513171657-edy6hx4","Type":"NodeParagraph","Properties":{"id":"20250513171657-edy6hx4","updated":"20250513171657"},"Children":[{"Type":"NodeText","Data":"软件性能测试是一种重要的质量保证机制，可以识别优化机会。自动化此过程需要强大的工具支持，尤其是在持续集成 （CI） 的情况下，测试需要完全自动运行，并且需要为开发人员提供可操作的反馈。缺乏现有工具意味着性能测试通常被排除在 CI 的范围之外。在本文中，我们提出了一个工具链 - PerfCI - 为开发人员在 CI 下轻松设置和执行自动化性能测试铺平了道路。我们的工具链基于允许用户 （1） 指定性能测试任务，（2） 通过扩展性能分析框架 （VyPR） 来分析各种 python 项目的单元测试，从脚本到成熟的基于 Flask 的 Web 服务，以及 （3） 评估性能数据以获得代码反馈。"}]},{"ID":"20250513171657-2mt1at7","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513171657-2mt1at7","updated":"20250513171717"},"Children":[{"Type":"NodeText","Data":"MOTIVATING SCENARIOS"}]},{"ID":"20250513171657-uxe3cui","Type":"NodeParagraph","Properties":{"id":"20250513171657-uxe3cui","updated":"20250513171717"},"Children":[{"Type":"NodeText","Data":"情景1：开发人员希望"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);"},"TextMarkType":"text","TextMarkTextContent":"分析控制流路径在运行时出现的频率[ 17 ]。这通常是通过剖析技术来完成的"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);\"}"},{"Type":"NodeText","Data":"。在我们的工具链中，用户可以将现有的工具作为任务(见3.1节第1阶段)进行插件，因此可以通过在中心配置文件中添加一个分析任务来进行分析。如果将这样的任务添加到配置文件中，单元测试也相应地被插桩，从而可以自动收集数据进行性能测试。"}]},{"ID":"20250513171657-0pmixc4","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513171657-0pmixc4","updated":"20250513171758"},"Children":[{"Type":"NodeText","Data":"PERFCI TOOLCHAIN"}]},{"ID":"20250513171657-ewdp6nr","Type":"NodeParagraph","Properties":{"id":"20250513171657-ewdp6nr","updated":"20250513171745"},"Children":[{"Type":"NodeText","Data":"PerfCI 允许开发人员使用其现有的 CI 设置和单元测试来识别有问题的代码区域，并获得可操作的反馈以做出优化决策。为此，PerfCI 提供了一个中央配置文件，开发人员可以在其中定义 CI 期间要执行的任务以及 VyPR 应监控的规范。CI 完成后，我们提供了 VyPR 分析库的扩展版本 [9]，使用户能够分析与单元测试结果相关的性能数据，以获得可操作的反馈。将我们的可配置 CI 方法与扩展的分析库相结合，PerfCI 采取了三个关键步骤，如图 1 所示。"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);"},"TextMarkType":"text","TextMarkTextContent":"为简洁起见，我们只显示单元测试阶段"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);\"}"},{"Type":"NodeText","Data":"，但可以有许多阶段，尤其是在配置许多分析时。在图中，虚线代表我们工具链的功能：1） 用户指定性能测试任务;2） VyPR 在单元测试执行时监控给定的系统;3） 用户分析数据以获得有关代码的可操作反馈。现在，我们将更详细地解释这些阶段中的每一个。"}]},{"ID":"20250513171657-03cngu8","Type":"NodeParagraph","Properties":{"id":"20250513171657-03cngu8","updated":"20250513171657"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513171657-j9ddm4x.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513171657-ywh0afg","Type":"NodeList","ListData":{},"Properties":{"id":"20250513171657-ywh0afg","updated":"20250513171657"},"Children":[{"ID":"20250513171657-prxkfcd","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513171657-prxkfcd","updated":"20250513171657"},"Children":[{"ID":"20250513171657-4yoq75d","Type":"NodeParagraph","Properties":{"id":"20250513171657-4yoq75d","updated":"20250513171657"},"Children":[{"Type":"NodeText","Data":"第一阶段：指定性能测试任务"}]}]}]},{"ID":"20250513171657-ofa73rw","Type":"NodeParagraph","Properties":{"id":"20250513171657-ofa73rw","updated":"20250513171657"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://gitlab.cern.ch/omjaved/perfci/","TextMarkTextContent":"PerfCI"},{"Type":"NodeText","Data":"的主要功能之一是用户能够在配置文件中轻松定义性能测试任务。这些任务包括 1） 将输入传递给测试套件;2） 通过插件连接现有工具，以便进行特定的性能分析;3） 对 input 空间进行切片（在对特定 inputs 集运行 performance analysis 时很有用）。用户还可以定义性能规范，以允许根据单个单元测试执行来分析系统的性能。性能测试任务在 YAML 文件中指定。选择 YAML 有两个原因：1） 由于 YAML 的格式简单，很容易定义性能测试任务，以及 2） 用户可以直接将 Python 代码嵌入到 YAML 文件中。我们的 YAML 文件放置在基础 CI 文件所在的项目的根目录中，例如 '.gitlab-ci.yml'。给定 YAML 文件，PerfCI 会使用其他配置更新基本 CI 文件。推送时，由定义的任务组成的性能测试阶段将添加到现有 CI 管道中。"}]},{"ID":"20250513171657-r5zg3vz","Type":"NodeList","ListData":{},"Properties":{"id":"20250513171657-r5zg3vz","updated":"20250513171657"},"Children":[{"ID":"20250513171657-03ezata","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513171657-03ezata","updated":"20250513171657"},"Children":[{"ID":"20250513171657-eovtm44","Type":"NodeParagraph","Properties":{"id":"20250513171657-eovtm44","updated":"20250513171657"},"Children":[{"Type":"NodeText","Data":"第二阶段：监测"}]}]}]},{"ID":"20250513171657-u62tnwp","Type":"NodeParagraph","Properties":{"id":"20250513171657-u62tnwp","updated":"20250513171758"},"Children":[{"Type":"NodeText","Data":"为了监控单元测试执行的代码是否存在性能问题，我们"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);"},"TextMarkType":"text","TextMarkTextContent":"使用了 VyPR，这是一个基于 Runtime Verification 的框架。运行时验证通常包括执行动态分析"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);\"}"},{"Type":"NodeText","Data":"，以确定程序的运行是否满足某些指定的行为。我们选择 Runtime Verification 的原因有两个。首先，它补充了软件测试 [5]。其次，可以选择用于行为规范的语言，以便运行与规范的程序不一致，可以通过生成错误的判决来立即破坏 CI 流程。VyPR 正在 CERN 的 CMS 实验中用于性能分析，它允许这种行为，因为它的规范语言（ControlFlow Temporal Logic [10]）确保一旦达到，错误的判断将永远不会改变。由于任何系统的性能都会因正在处理的输入而有很大差异，因此，为了让 VyPR 在不同输入下运行时监控代码，我们提供了一个测试运行程序来处理基于不同输入的单元测试的执行。我们通过参数化单元测试运行程序来实现这一点，即输入作为参数在测试运行程序中传递，该测试运行程序可以根据提供的不同输入执行应用程序代码。此外，在不同的输入上重复运行单元测试有助于确定性能下降是一直发生，还是在单元测试执行的代码中的特定输入下发生。"}]}]}