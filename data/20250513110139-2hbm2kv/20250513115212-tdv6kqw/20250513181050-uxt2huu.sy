{"ID":"20250513181050-uxt2huu","Spec":"1","Type":"NodeDocument","Properties":{"id":"20250513181050-uxt2huu","title":"2008-WOSP-A Framework for Measurement Based Performance Modeling","type":"doc","updated":"20250513181149"},"Children":[{"ID":"20250513181055-p1rs091","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513181055-p1rs091","updated":"20250513181100"},"Children":[{"Type":"NodeText","Data":"摘要"}]},{"ID":"20250513181055-b58eph4","Type":"NodeParagraph","Properties":{"id":"20250513181055-b58eph4","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"性能建模技术大致分为测量技术、分析技术和基于仿真的技术。在实际应用中，通常采用基于测量的性能建模方法。基于测量的建模需要执行大量的性能测试来建立准确的性能模型。每个应用程序的发布或构建都必须重复进行这些性能测试。这是一个耗时且易出错的手工过程。"}]},{"ID":"20250513181055-ztvqr52","Type":"NodeParagraph","Properties":{"id":"20250513181055-ztvqr52","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"在本文中，我们提出了一个基于测量的性能模型的系统化和自动化构建框架。该框架基于我们对两个大型应用程序的性能建模经验：Dell公司的DVD Store应用程序和另一个较大的企业级应用程序。我们使用Dell DVD Store应用程序作为运行实例来演示我们框架中的各个步骤。我们展示了我们的框架的优点和缺点。我们讨论采用我们的框架所预期的努力减少。"}]},{"ID":"20250513181055-5d9svhc","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513181055-5d9svhc","updated":"20250513181143"},"Children":[{"Type":"NodeText","Data":"INTRODUCTION"}]},{"ID":"20250513181055-u81i8w3","Type":"NodeParagraph","Properties":{"id":"20250513181055-u81i8w3","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"软件应用的性能建模至关重要。软件应用部署后出现的问题很少是由于功能错误造成的。相反，大多数问题与应用程序响应不够快，在重载下崩溃或挂起，以及其他与性能或容量相关的问题有关[ 7 ]。"}]},{"ID":"20250513181055-eeykk36","Type":"NodeParagraph","Properties":{"id":"20250513181055-eeykk36","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"性能建模是软件性能工程的一部分，其目的是建立性能模型以更好地理解应用程序在不同的工作负载和部署(硬件和平台)设置下的性能特征。性能建模技术大致分为基于测量、基于分析和基于仿真的技术。基于测量的技术依赖于对正在研究的应用程序进行广泛的性能测试。基于测量的技术只有在应用完全开发和可用的情况下才能进行。为了克服这一局限性，分析和仿真技术通过建立模型来提前研究和预测应用程序的性能特征。分析技术采用理论模型。仿真技术使用计算机仿真来模拟应用程序的功能，其性能可以被探测。人们已经对使用这三种技术进行软件应用的性能建模进行了深入的研究[ 4 ]。基于模拟和分析的技术都需要对应用有很好的理解，并要求对其行为有准确的记录。(MT是否适用) 然而，在实际应用中很少有最新的、完整的文档和对应用程序的理解。源代码在很多情况下代表了有关应用程序的准确信息的唯一来源[ 18 ]。因此，实践者通常使用基于测量的技术。Sankarasetty等[ 1 ]指出，基于测量的技术往往是实践中使用的唯一类型的性能分析。"}]},{"ID":"20250513181055-dlmqcq5","Type":"NodeParagraph","Properties":{"id":"20250513181055-dlmqcq5","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"基于测量的技术要求对软件应用程序的每个发布或构建执行大量的性能测试。性能测试是在特定的软硬件配置下，针对特定的工作负载，测量应用程序的性能特征(例如,响应时间)。性能测试通常在应用程序的功能测试和负载测试完成后进行。功能测试检查一个应用是否满足其功能需求。(?) 负载测试检查应用程序在繁重的工作负载下是否正常工作。功能测试和负载测试都会导致每次测试的通过或失败分类。相比之下，性能测试的结果是通过响应时间等指标进行定量总结的。利用大量性能测试的结果，可以建立性能模型。企业应用的部署人员在部署新应用[ 6、11、19]时，使用该性能模型来确定最合适的容量配置。这个过程通常被认为是能力规划。"}]},{"ID":"20250513181055-uvn0a6u","Type":"NodeParagraph","Properties":{"id":"20250513181055-uvn0a6u","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"为了保证性能模型的完整和准确，必须进行大量的性能测试。大量的试验导致在实际中进行基于测量的建模时面临许多挑战。设置执行每次测试的环境通常是一个手动的过程，过程冗长且容易出错。设置错误是常见的，代价昂贵的，并且通常难以检测。由于试验是多次重复的，因此试验设置过程是多次重复的。重复测试以确保结果的统计有效性，并研究应用程序在不同硬件和平台设置下的性能。随着软件应用程序的每个构建或版本，必须通过重新运行大部分性能测试来更新基于度量的模型。建立和维护基于测量的模型是一个耗时和资源密集型的过程。例如，如果在性能建模过程中发现了应用程序中的缺陷，那么一旦缺陷被修复，整个性能建模过程通常会重复进行。"}]},{"ID":"20250513181055-3ugxw0t","Type":"NodeParagraph","Properties":{"id":"20250513181055-3ugxw0t","updated":"20250513181136"},"Children":[{"Type":"NodeText","Data":"许多实践都集中于自动化性能测试，而不是建模。工业界主要致力于构建成熟的负载测试工具，如WebLOAD ("},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"http://www.webload.org/","TextMarkTextContent":"http://www.webload.org/"},{"Type":"NodeText","Data":")[ 13 ]和HP LoadRunner (https://h10078.www1.hp.com/cda/hpms/display/main/hpms"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"_"}]},{"Type":"NodeText","Data":" content.jsp?zn"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"="}]},{"Type":"NodeText","Data":"bto\u0026cp"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"="}]},{"Type":"NodeText","Data":"1-11-126-17%5E8"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"_"}]},{"Type":"NodeText","Data":"4000"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"_"}]},{"Type":"NodeText","Data":"100"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"_"}]},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"_"}]},{"Type":"NodeText","Data":") [ 14 ]。这些工具虽然对性能测试非常有价值，但无助于解决基于测量的性能建模的全生命周期问题。由于基于测量的性能建模是一个已经发布的时间表的最后步骤之一，因此需要技术来加速建模过程。"}]},{"ID":"20250513181055-9dc2kuk","Type":"NodeParagraph","Properties":{"id":"20250513181055-9dc2kuk","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"在本文中，我们提出了一个包含基于测量的性能建模的全生命周期的框架。该框架将挑选合适的负载测试执行的过程自动化，以构建准确且具有代表性的模型。然后，该框架使用现成的负载测试工具(如HP LoadRunner )自动设置负载测试。"}]},{"ID":"20250513181055-4y8nlxh","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513181055-4y8nlxh","updated":"20250513181144"},"Children":[{"Type":"NodeText","Data":"基于测量的性能建模在实践中的挑战"}]},{"ID":"20250513181055-zvd0bqk","Type":"NodeParagraph","Properties":{"id":"20250513181055-zvd0bqk","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"1 )必须执行的大量测试。为了确保模型能够捕获应用程序的各种可能的工作负载和配置选项，必须执行大量的测试。例如，需要对应用程序的各种配置设置进行测试。测试可以重复多次，以获得捕获性能指标的统计置信度。必须在多个平台上进行测试，才能对改变底层硬件平台的效果进行建模和基准测试。"}]},{"ID":"20250513181055-1pkeilu","Type":"NodeParagraph","Properties":{"id":"20250513181055-1pkeilu","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"2 )可用于性能建模的有限时间。性能建模通常作为已经很紧的、通常延迟的发布计划中的最后一步进行。因此，管理者总是希望减少分配给性能建模的时间。"}]},{"ID":"20250513181055-zz4jcai","Type":"NodeParagraph","Properties":{"id":"20250513181055-zz4jcai","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"3 )手动设置、执行和分析测试过程而导致的错误风险。有许多工具可以帮助自动生成用于性能测试的负载。然而，目前还没有工具以自动化的方式配置被测应用程序、设置测试和分析结果。在实际应用中，所有这些任务都是由人工完成的，特别容易出错。"}]},{"ID":"20250513181055-o1h5st5","Type":"NodeParagraph","Properties":{"id":"20250513181055-o1h5st5","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"4 )需要重复整个建模过程的风险。建模过程中经常会发现问题或错误配置。一旦确定的问题得到解决，建模过程必须从零开始重新启动，同时对性能模型分配的时间影响最小"}]},{"ID":"20250513181055-zfje22x","Type":"NodeParagraph","Properties":{"id":"20250513181055-zfje22x","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"这些挑战也被其他研究者和实践者注意到。例如，贡特尔将冗长的测量和建模阶段作为管理层对性能建模和能力规划持怀疑态度的主要原因[ 8 ]。"}]},{"ID":"20250513181055-ql6x37m","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513181055-ql6x37m","updated":"20250513181149"},"Children":[{"Type":"NodeText","Data":"OUR PERFORMANCE MODELING FRAMEWORK"}]},{"ID":"20250513181055-7e4a5a7","Type":"NodeParagraph","Properties":{"id":"20250513181055-7e4a5a7","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"我们提出了一个性能建模框架来解决上述挑战，具体如下："}]},{"ID":"20250513181055-er478db","Type":"NodeParagraph","Properties":{"id":"20250513181055-er478db","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"1 )必须执行的大量测试。我们提出的框架支持使用先进的测试选择和优先排序技术，如ANOVA选择[ 9 ]和筛选设计[ 10 ]，以减少测试的数量。该框架还支持从应用程序的先前发布或构建中重用数据。"}]},{"ID":"20250513181055-rtuhd9h","Type":"NodeParagraph","Properties":{"id":"20250513181055-rtuhd9h","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"2 )可用于性能建模的有限时间。该框架自动化了构建性能模型所需的大量耗时任务。该框架还减少了测试所需的时间。"}]},{"ID":"20250513181055-ny6zck8","Type":"NodeParagraph","Properties":{"id":"20250513181055-ny6zck8","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"3 )由于手动设置、执行和分析测试过程而导致的错误风险。该框架实现了环境搭建、测试执行和分析测试的自动化。这种自动化保证了错误是最小的。此外，该框架包含一个验证步骤，该步骤使用先前的性能测试和启发式方法来标记可能的坏测试，并重新运行它们或将它们从模型建立步骤中移除。"}]},{"ID":"20250513181055-hp24xjb","Type":"NodeParagraph","Properties":{"id":"20250513181055-hp24xjb","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"4 )需要重复整个建模过程的风险。该框架检测并标记可能存在问题或错误配置的性能测试。建模过程可以在问题解决后自动增量执行。"}]},{"ID":"20250513181055-793w29y","Type":"NodeParagraph","Properties":{"id":"20250513181055-793w29y","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513181055-pao0qe9.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513181055-uc5c6ht","Type":"NodeParagraph","Properties":{"id":"20250513181055-uc5c6ht","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"图2展示了我们框架中的各个步骤："}]},{"ID":"20250513181055-an3otaa","Type":"NodeParagraph","Properties":{"id":"20250513181055-an3otaa","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"1 )测试枚举确定应执行的性能测试集合。测试枚举步骤的目的是定义所有需要执行的测试的搜索空间，以建立准确的性能模型。"}]},{"ID":"20250513181055-2pn1h1i","Type":"NodeParagraph","Properties":{"id":"20250513181055-2pn1h1i","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"2 )测试精简利用领域知识和先前运行的历史信息来减少性能测试的数量。此外，测试约简使用统计和实验设计技术来减少应该运行的测试数量。"}]},{"ID":"20250513181055-c44zubq","Type":"NodeParagraph","Properties":{"id":"20250513181055-c44zubq","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"3 )环境设置自动设置性能测试环境。这包括安装应用程序和负载测试工具。应用程序和工具可能需要在不同的操作系统平台上运行。为了支持多平台应用，从业者可以定制这个步骤，并在跨平台中重用其他步骤。"}]},{"ID":"20250513181055-f8e1huq","Type":"NodeParagraph","Properties":{"id":"20250513181055-f8e1huq","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"4 )测试执行，自动化运行测试套件的任务。它有三个主要的活动：Test Setup、Test Run和Test Shutdown。该步骤是可定制的，允许使用可以自动调用(例如,从命令行)的性能/负载测试工具。"}]},{"ID":"20250513181055-tulseau","Type":"NodeParagraph","Properties":{"id":"20250513181055-tulseau","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"5 )测试转换为框架中执行第一步指定的测试提供了环境，从业可以在待测系统完全恢复和重启的一个极端和直接启动负载的另一个极端之间配置框架，以便进行下一步的测试。一旦配置完成，框架在完成每次性能测试后自动执行转换步骤。"}]},{"ID":"20250513181055-3cgxxz3","Type":"NodeParagraph","Properties":{"id":"20250513181055-3cgxxz3","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"6 )测试分析阶段，首先将测试结果与其他测试结果和启发式方法进行比较，以发现性能测试本身存在的问题。其次，对性能计数器的度量指标进行分析，得出性能计数器与注入负载之间的关系。"}]},{"ID":"20250513181055-n2weunc","Type":"NodeParagraph","Properties":{"id":"20250513181055-n2weunc","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"7 )模型建立在最后一步中，使用统计分析工具建立了一个回归模型，该模型将应用程序的性能建模为其负载参数的函数。"}]},{"ID":"20250513181055-tsknxxh","Type":"NodeParagraph","Properties":{"id":"20250513181055-tsknxxh","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"性能数据库存储性能测试和分析数据。该数据库用于测试归约、测试分析和模型建立等步骤。该数据库可以使用复杂的数据库系统实现，也可以使用文件实现。该框架允许性能分析师每天对建模过程中使用的各种启发式进行编码。通过对启发式进行编码，确保其模型构建过程具有可重复性。启发法的文档允许分析人员仔细检查这些启发法，并随着他们对应用程序的理解的成熟而更新它们。随着建模过程的发展，分析人员也可以用更复杂的技术来取代他们的启发式方法。在接下来的小节中，我们对每一小节进行了详细的描述。"}]},{"ID":"20250513181055-yg8ivdr","Type":"NodeParagraph","Properties":{"id":"20250513181055-yg8ivdr","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"下面我们简单介绍一下Dell DVD Store应用。DVD Store ( DVD Store 2或DS2)应用是一款开源的企业级软件应用。DS2应用程序是由戴尔公司开发的，作为戴尔硬件解决方案的白皮书和演示的基准工作负载[ 2 ]。DS2试图在架构和功能上模仿当今的网上商店。Ds2具有三层结构。DS2包括应用服务器组件、数据库服务器组件和负载生成器引擎(客户端仿真器)。负载生成器的源代码可用，并在各种平台上运行。负载生成器可以在不同的应用服务器上生成负载，也可以直接在数据库服务器上生成负载，完全跳过应用服务器。负载生成器通过向应用前端发送HTTP请求来模拟网站用户。应用前端对各种业务规则进行编码，例如订购新的标题，在库存不足的情况下拒绝订单等。所有客户、标题和交易数据都存储在数据库服务器层。由于多种原因，我们选择了DS2而不是其他应用。首先，它是一个开源的应用程序，允许我们调试和修复应用程序中的许多问题。第二，使用简单、直观，通过命令行界面。第三，它不需要任何商业软件就可以运行；使用Apache Tomcat作为应用服务器，MySQL作为数据库服务器。我们现在解释我们的性能建模框架使用的每一个步骤。"}]},{"ID":"20250513181055-hzyuyaq","Type":"NodeList","ListData":{},"Properties":{"id":"20250513181055-hzyuyaq","updated":"20250513181055"},"Children":[{"ID":"20250513181055-w0bf13r","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-w0bf13r","updated":"20250513181055"},"Children":[{"ID":"20250513181055-jjq7h7v","Type":"NodeParagraph","Properties":{"id":"20250513181055-jjq7h7v","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"测试枚举"}]}]}]},{"ID":"20250513181055-5jwuzk0","Type":"NodeParagraph","Properties":{"id":"20250513181055-5jwuzk0","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"对一个软件应用进行性能建模的第一步是列举出应该执行的性能测试列表，以建立满足用户需求的性能模型。这一步是我们框架中唯一的手动步骤。我们的框架自动化执行其余步骤。测试枚举步骤包括四个阶段。我们使用DS2应用程序在每个阶段下面进行讨论。"}]},{"ID":"20250513181055-6yaa6b1","Type":"NodeList","ListData":{},"Properties":{"id":"20250513181055-6yaa6b1","updated":"20250513181055"},"Children":[{"ID":"20250513181055-j6rzcoe","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-j6rzcoe","updated":"20250513181055"},"Children":[{"ID":"20250513181055-sl5o0bk","Type":"NodeParagraph","Properties":{"id":"20250513181055-sl5o0bk","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"第一阶段：功能性交易的列举"}]}]}]},{"ID":"20250513181055-gh3tbku","Type":"NodeParagraph","Properties":{"id":"20250513181055-gh3tbku","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"性能分析师从列举应用程序中可用的功能事务开始。DS2中的功能性交易为："}]},{"ID":"20250513181055-p0nkxq2","Type":"NodeList","ListData":{},"Properties":{"id":"20250513181055-p0nkxq2","updated":"20250513181055"},"Children":[{"ID":"20250513181055-t44doun","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-t44doun","updated":"20250513181055"},"Children":[{"ID":"20250513181055-lk6c63x","Type":"NodeParagraph","Properties":{"id":"20250513181055-lk6c63x","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"创建新的客户档案"}]}]},{"ID":"20250513181055-ulr4kdo","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-ulr4kdo","updated":"20250513181055"},"Children":[{"ID":"20250513181055-02wad2g","Type":"NodeParagraph","Properties":{"id":"20250513181055-02wad2g","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"客户登录"}]}]},{"ID":"20250513181055-xosuj9g","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-xosuj9g","updated":"20250513181055"},"Children":[{"ID":"20250513181055-wtt5ydr","Type":"NodeParagraph","Properties":{"id":"20250513181055-wtt5ydr","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"按类别、演员、体裁等检索标题"}]}]},{"ID":"20250513181055-heqviar","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-heqviar","updated":"20250513181055"},"Children":[{"ID":"20250513181055-qzm2v4k","Type":"NodeParagraph","Properties":{"id":"20250513181055-qzm2v4k","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"购买一个标题"}]}]},{"ID":"20250513181055-0j0tgoz","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-0j0tgoz","updated":"20250513181055"},"Children":[{"ID":"20250513181055-5xqmaqe","Type":"NodeParagraph","Properties":{"id":"20250513181055-5xqmaqe","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"第二阶段：将功能事务映射到工作负载类"}]}]}]},{"ID":"20250513181055-hfq7org","Type":"NodeParagraph","Properties":{"id":"20250513181055-hfq7org","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"性能分析人员需要将功能事务映射到工作负载类。可以将多个事务分组并建模为单个工作负载，也可以将每个事务建模为单独的工作负载。分析人员应该根据模型中所要求的粒度和细节级别来决定。例如，对于DS2应用程序，如果我们对每个单独事务的性能需求建模不感兴趣，我们可以将登录-搜索-购买事务的序列视为单个工作负载，正如Dell的研究人员所做的那样[ 6 ]。相反，我们决定将每个事务视为一个工作负载类。我们认为，登录-搜索-购买的顺序作为一个单一的工作负载可能不是一个有效的假设，因为一个用户可能在做出操作之前进行多次搜索操作"}]},{"ID":"20250513181055-60lphm8","Type":"NodeList","ListData":{},"Properties":{"id":"20250513181055-60lphm8","updated":"20250513181055"},"Children":[{"ID":"20250513181055-darbp8d","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-darbp8d","updated":"20250513181055"},"Children":[{"ID":"20250513181055-6ds5f4r","Type":"NodeParagraph","Properties":{"id":"20250513181055-6ds5f4r","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"第三阶段：为测试执行优先分配工作负载类"}]}]}]},{"ID":"20250513181055-mtx0q6w","Type":"NodeParagraph","Properties":{"id":"20250513181055-mtx0q6w","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"由于框架将执行测试以确保每个工作负载在最终的性能模型中被表示，因此工作负载类应该被优先考虑。例如，如果为一个新的版本建立性能模型，其中购买功能已被修改为接受新的支付方式，分析师可能会决定只执行与购买工作量相对应的测试，并从应用程序的旧模型中重用数据进行其他测试。"}]},{"ID":"20250513181055-clfdw02","Type":"NodeList","ListData":{},"Properties":{"id":"20250513181055-clfdw02","updated":"20250513181055"},"Children":[{"ID":"20250513181055-c1i41xg","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-c1i41xg","updated":"20250513181055"},"Children":[{"ID":"20250513181055-5ae8j6k","Type":"NodeParagraph","Properties":{"id":"20250513181055-5ae8j6k","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"第四阶段：选取每个工作负荷类别的取值范围以及在该范围内的步长"}]}]}]},{"ID":"20250513181055-fggzxmg","Type":"NodeParagraph","Properties":{"id":"20250513181055-fggzxmg","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"每个工作负载类的范围和范围内的步长是根据分析的经验、对最终性能模型的要求以及关于应用程序的历史知识来选择的。例如，如果特定的设置会使硬件资源充分利用，那么工作负载可能会过高，使系统无法处理，因此应调整范围。在没有历史数据的情况下，可能需要进行一些试错来确定量程和步长，以使测量点均匀分布。现在，我们列出了DS2工作负载类的可用设置，以便我们可以枚举具有不同值的测试："}]},{"ID":"20250513181055-led72v1","Type":"NodeList","ListData":{},"Properties":{"id":"20250513181055-led72v1","updated":"20250513181055"},"Children":[{"ID":"20250513181055-hzehxp2","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-hzehxp2","updated":"20250513181055"},"Children":[{"ID":"20250513181055-hicjfb3","Type":"NodeParagraph","Properties":{"id":"20250513181055-hicjfb3","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"交易频率：每小时交易次数。"}]}]},{"ID":"20250513181055-66bu75s","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-66bu75s","updated":"20250513181055"},"Children":[{"ID":"20250513181055-c6718zq","Type":"NodeParagraph","Properties":{"id":"20250513181055-c6718zq","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"并发性：并发产生应用程序负载的进程数或线程数。"}]}]},{"ID":"20250513181055-358ms9l","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-358ms9l","updated":"20250513181055"},"Children":[{"ID":"20250513181055-hvnx8ts","Type":"NodeParagraph","Properties":{"id":"20250513181055-hvnx8ts","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"检索类别：按名称、类别、演员或体裁进行检索。"}]}]},{"ID":"20250513181055-magg86n","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-magg86n","updated":"20250513181055"},"Children":[{"ID":"20250513181055-ojw3mzj","Type":"NodeParagraph","Properties":{"id":"20250513181055-ojw3mzj","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"购买量：一次交易购买DVD的数量。"}]}]}]},{"ID":"20250513181055-chnmsw6","Type":"NodeParagraph","Properties":{"id":"20250513181055-chnmsw6","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513181055-bvg9jyk.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513181055-ldp1799","Type":"NodeParagraph","Properties":{"id":"20250513181055-ldp1799","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"频率和并发设置适用于所有四个工作负载类。搜索类别设置仅适用于搜索工作量。采购数量设置仅适用于采购工作量。表1给出了各种设置与工作负载类别之间的关系。(频率、并发、搜索、购买)的4个设置均有4个等级。"}]},{"ID":"20250513181055-lth3rom","Type":"NodeParagraph","Properties":{"id":"20250513181055-lth3rom","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"性能测试应在每个工作负载的可用设置的各种组合下进行。例如，Login工作负载类有4个级别的频率和并发设置，导致16种可能的组合，需要进行性能测试。通过研究DS2应用程序的文档，我们决定不考虑工作负载类之间的交互，因为每个工作负载类都有一个独立于其他工作负载类的服务需求。基于我们的假设和设置数量，我们一共列举了144个性能测试，详见表1。如果一个性能分析师要考虑工作负载类之间的相互作用，那么使用析因试验设计技术[ 4 ]，测试的数量会更多，因为总的测试数量是每个工作负载类可能的测试数量的乘法。"}]},{"ID":"20250513181055-fpb3krv","Type":"NodeList","ListData":{},"Properties":{"id":"20250513181055-fpb3krv","updated":"20250513181055"},"Children":[{"ID":"20250513181055-fj75poz","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-fj75poz","updated":"20250513181055"},"Children":[{"ID":"20250513181055-nbcxkz7","Type":"NodeParagraph","Properties":{"id":"20250513181055-nbcxkz7","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"测试精简"}]}]}]},{"ID":"20250513181055-1wb6b0a","Type":"NodeParagraph","Properties":{"id":"20250513181055-1wb6b0a","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"测试精简是框架中的第二步，如图2所示。正如第2节所讨论的那样，大量的性能测试和较长的测试时间是基于测量的性能建模中的一些关键挑战。因此，有必要在框架中引入该步骤，以减少数量性能测试。然而，对性能测试精简方法的研究很少。在这一部分，我们借鉴其他研究领域的思想，提出了几种性能测试精简方法。我们将这些方法归为静态和动态两种类型。静态测试精简是一个手工的过程，需要很好地了解性能模型的要求和应用程序的实现。动态测试精简方法以数学工具和技术为基础，内置于框架中，自动执行。"}]},{"ID":"20250513181055-74i3ws2","Type":"NodeList","ListData":{},"Properties":{"id":"20250513181055-74i3ws2","updated":"20250513181055"},"Children":[{"ID":"20250513181055-ga8vhyj","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-ga8vhyj","updated":"20250513181055"},"Children":[{"ID":"20250513181055-qjv5498","Type":"NodeParagraph","Properties":{"id":"20250513181055-qjv5498","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"静态测试精简"}]}]}]},{"ID":"20250513181055-hbsem8n","Type":"NodeParagraph","Properties":{"id":"20250513181055-hbsem8n","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"在一个大型的软件应用中，通常存在多个功能事务。然而，所有的功能事务对于性能建模可能并不重要。例如，希望部署DVD Store应用程序的客户对管理功能的性能不感兴趣。相反，他们想知道店面在客户操作方面是如何表现的。因此，可以过滤掉不感兴趣的功能性交易。这样的约简方法是从需求的知识中得出的。"}]},{"ID":"20250513181055-wsrdfo2","Type":"NodeParagraph","Properties":{"id":"20250513181055-wsrdfo2","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"另一组精简方法则借鉴了关于实施的知识。例如，如果两个特征彼此相似，那么只对其中一个特征进行性能测试就足够了。例如，购买DVD和购买DVD Collection功能可能仅有几个代码模块不同，因此性能分析人员可以决定建立一个只捕获其中一个功能的模型，以减少所需测试的数量，至少在模型建立的第一轮迭代中。"}]},{"ID":"20250513181055-87k85nb","Type":"NodeList","ListData":{},"Properties":{"id":"20250513181055-87k85nb","updated":"20250513181055"},"Children":[{"ID":"20250513181055-cg8v7tz","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-cg8v7tz","updated":"20250513181055"},"Children":[{"ID":"20250513181055-9yeabkc","Type":"NodeParagraph","Properties":{"id":"20250513181055-9yeabkc","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"动态测试精简"}]}]}]},{"ID":"20250513181055-kyc8jtt","Type":"NodeParagraph","Properties":{"id":"20250513181055-kyc8jtt","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"在功能测试领域[ 22、23 ]中，对测试精简的思想进行了深入的研究。然而，这种思想对于性能测试和建模的探索并不多。我们提出了一些方法，这些方法虽然用于其他目的，但在这里可以实际使用。帕累托原则[ 25 ]认为，少量的应用特征占大多数问题。这一原则既适用于功能问题，也适用于性能问题。动态测试精简技术旨在找出那些对应用性能有显著贡献的少数特征，并只执行与这些特征相对应的测试。"}]},{"ID":"20250513181055-sdsb70o","Type":"NodeParagraph","Properties":{"id":"20250513181055-sdsb70o","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"在大型应用中，少数具有较大服务需求的重要工作负载类对整体应用性能的影响较大，而其他工作负载类的性能影响很小或可以忽略不计。一旦使用少量的性能测试挖掘出那些具有较大服务需求的工作负载类，就可以避免对这些不太重要的工作负载类的进一步测试，并且在准确性上损失很小或没有损失。Porter等人[ 10 ]提出了一种称为主屏幕分析( Main Screen Analysis )的方法来找出影响应用程序性能的重要配置参数。Menasc é和Sopitkamol在[ 9 ]中使用双因素方差分析( two-way ANOVA )对显著影响整体应用性能的配置参数进行了排序。这两项工作都可以根据它们对整体性能的重要性来对负载类别进行排序。一旦性能参数按其对性能的重要性进行排序，影响最小的参数对应的测试可以以最小的精度损失从分析中删除。Porter等人、Menasc é和Sopitkomal所使用的技术都是基于试验设计理论的。文献[ 4 ]对实验设计技术进行了详细的讨论。"}]},{"ID":"20250513181055-c2l1ls1","Type":"NodeParagraph","Properties":{"id":"20250513181055-c2l1ls1","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"该框架支持以即插即用的方式使用上述方法或其他研究工作。在我们的案例研究中，我们使用了一种简化的方法进行测试精简。我们对每个工作负载类运行两个极端性能测试：一个具有最低值，另一个具有整个工作负载大小数组中的最高值，这是在测试枚举步骤之后得到的。例如，我们对采购工作量进行了测试，其数量为：1和1000。如果该框架没有发现这两个测试在性能上的显著差异，则该框架跳过中间值对应的测试。然而，如果该框架发现由于参数设置(如并发量、频率和搜索类型等)导致的性能显著差异，则对这些设置进行其余测试。采用这种简化方法，可以将测试次数从144次减少到64次。精简后的性能测试列表如表2所示。"}]},{"ID":"20250513181055-gm6lqcq","Type":"NodeParagraph","Properties":{"id":"20250513181055-gm6lqcq","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513181055-ut2qpnx.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513181055-mcemyq8","Type":"NodeList","ListData":{},"Properties":{"id":"20250513181055-mcemyq8","updated":"20250513181055"},"Children":[{"ID":"20250513181055-8kthi1l","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-8kthi1l","updated":"20250513181055"},"Children":[{"ID":"20250513181055-p45vpxq","Type":"NodeParagraph","Properties":{"id":"20250513181055-p45vpxq","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"环境设置"}]}]}]},{"ID":"20250513181055-cea7h1v","Type":"NodeParagraph","Properties":{"id":"20250513181055-cea7h1v","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"环境设置是框架中的第三步，如图2所示。这一步的目的是安装应用程序和性能/负载测试工具。目前工业中的环境设置是一个手工的、临时的、容易出错的过程。对于自动化实现这一步的研究工作并不多。"}]},{"ID":"20250513181055-g5fiei7","Type":"NodeParagraph","Properties":{"id":"20250513181055-g5fiei7","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"在我们的框架中，我们使用一组脚本在一个独立的模块中自动化实现了这一步，该脚本由框架引擎调用。脚本设置了多个计算机系统，包括应用服务器、数据库服务器、负载生成器和性能跟踪器。然后，脚本通过确保相关流程和服务的运行来验证环境设置的正确性。然而，每个应用和负载测试工具都有自己的安装步骤。因此，我们预计在将框架定制到另一个应用程序或平台时，在这一步需要大量的返工。我们将在第5节讨论定制我们的框架所需的努力。尽管该步骤需要大量的定制工作，但我们使用该框架的经验表明，自动化该步骤是值得的，因为定制工作是一次性的努力。"}]},{"ID":"20250513181055-hjmowdl","Type":"NodeList","ListData":{},"Properties":{"id":"20250513181055-hjmowdl","updated":"20250513181055"},"Children":[{"ID":"20250513181055-snue2az","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-snue2az","updated":"20250513181055"},"Children":[{"ID":"20250513181055-fp05xhj","Type":"NodeParagraph","Properties":{"id":"20250513181055-fp05xhj","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"测试执行"}]},{"ID":"20250513181055-mo0552k","Type":"NodeList","ListData":{},"Properties":{"id":"20250513181055-mo0552k","updated":"20250513181055"},"Children":[{"ID":"20250513181055-wudnh8a","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-wudnh8a","updated":"20250513181055"},"Children":[{"ID":"20250513181055-4pglqde","Type":"NodeParagraph","Properties":{"id":"20250513181055-4pglqde","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"测试设置（Test Setup）"}]}]}]}]}]},{"ID":"20250513181055-gexyonj","Type":"NodeParagraph","Properties":{"id":"20250513181055-gexyonj","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"应用程序的每个组件可能需要一组测试数据来进行特定的测试。例如，在我们的案例研究中，DVD Store应用程序需要加载DVD标题、注册客户和他们的购买历史的测试数据。测试设置的另一个重要任务是应用服务器、数据库服务器和负载生成器的配置。配置参数值的不同设置会导致性能结果的截然不同。将性能测试结果与其配置关联是测试分析阶段的重要内容。我们的框架将应用程序的配置文件与每次性能测试一起存档。"}]},{"ID":"20250513181055-m7go2cc","Type":"NodeParagraph","Properties":{"id":"20250513181055-m7go2cc","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"确信测试不会受到任何一次性异常的影响，包括在触发测试之前确保应用程序处于正确的状态。当计数器自相矛盾或与预期不符时，通常直到测试分析阶段才捕捉到测试设置的问题。因此，对测试装置进行验证是至关重要的。"}]},{"ID":"20250513181055-alu3p8r","Type":"NodeParagraph","Properties":{"id":"20250513181055-alu3p8r","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"我们的框架允许编写用于测试数据设置、配置和设置验证的自定义例程。这些例程在触发测试之前由框架调用，从而实现测试设置任务的完全自动化。我们使用该框架的经验表明，一旦这些自定义例程被实现，它们提供了显著的时间节省。"}]},{"ID":"20250513181055-pbmjwwx","Type":"NodeList","ListData":{},"Properties":{"id":"20250513181055-pbmjwwx","updated":"20250513181055"},"Children":[{"ID":"20250513181055-60f9aqk","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-60f9aqk","updated":"20250513181055"},"Children":[{"ID":"20250513181055-ks9xzq1","Type":"NodeParagraph","Properties":{"id":"20250513181055-ks9xzq1","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"测试运行（Test Run）"}]}]}]},{"ID":"20250513181055-ikrpg0i","Type":"NodeParagraph","Properties":{"id":"20250513181055-ikrpg0i","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"近年来，在负载和性能测试的自动化运行方面进行了大量的工作。成熟的性能/负载测试程序，如LoadRunner工具和WebLOAD是可用的。这些程序包括1 )记录一个代表正在测试的工作负载类的脚本的工具，2 )通过播放记录的脚本的多个实例来模拟现实生活中的并发用户来生成工作负载的工具。为了进行测试，从负载生成器中播放录制好的脚本的多个实例，同时探测应用程序的性能。一旦记录了代表工作负载类的脚本，每个测试的运行就是一个三步的过程：1 .启动性能计数器。2 .开启应用。3 .启动负载生成工具。"}]},{"ID":"20250513181055-kbnfx87","Type":"NodeParagraph","Properties":{"id":"20250513181055-kbnfx87","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"性能计数器的启动可以是该过程的最后一步，也可以是第一步。然而，首先启动计数器可以捕获应用程序在开启和负载增加时的瞬态响应。测试装置的这三个主要部件中的每个部件可能有多个子部件需要按适当的顺序开启。在连续的步骤之间可能需要适当的时间间隔。"}]},{"ID":"20250513181055-a6akqql","Type":"NodeParagraph","Properties":{"id":"20250513181055-a6akqql","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"与测试设置类似，该框架以模块化的方式允许对这一重要步骤进行脚本编写和错误检查，从而实现了运行测试的自动化。每次性能测试都要经历三个阶段："}]},{"ID":"20250513181055-67b4ri4","Type":"NodeParagraph","Properties":{"id":"20250513181055-67b4ri4","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"1 .预热( Warm-up )：也称为爬坡( ramp-up )阶段，在此期间应用程序受到工作负载的影响。然而，工作量并没有达到它的全部强度，而是正在朝着指定的工作量水平发展。"}]},{"ID":"20250513181055-fe26fnu","Type":"NodeParagraph","Properties":{"id":"20250513181055-fe26fnu","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"2 .稳态阶段：如果环境配置良好，应用程序可以维持工作负载，热身阶段就让位于稳态阶段。在这一阶段，性能指标相对于平均值呈正态分布。"}]},{"ID":"20250513181055-d3ravfm","Type":"NodeParagraph","Properties":{"id":"20250513181055-d3ravfm","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"3 .冷却：也被称为下倾斜阶段，在此期间，负载生成器逐渐停止注入工作负载，并且随着工作负载的减少，资源利用率逐渐下降。"}]},{"ID":"20250513181055-683srvf","Type":"NodeList","ListData":{},"Properties":{"id":"20250513181055-683srvf","updated":"20250513181055"},"Children":[{"ID":"20250513181055-0nid338","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-0nid338","updated":"20250513181055"},"Children":[{"ID":"20250513181055-5npi3kb","Type":"NodeParagraph","Properties":{"id":"20250513181055-5npi3kb","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"测试结束（Test Shutdown）"}]}]}]},{"ID":"20250513181055-bm4t83t","Type":"NodeParagraph","Properties":{"id":"20250513181055-bm4t83t","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"负载产生工具应停机。通常，负载生成工具是定时的，并且一旦测试完成就可以设置为关机。待测应用程序可能需要触发以关闭，也可能继续运行以进行后续测试。关闭或继续运行应用程序的决定由Test转换步骤决定。为了消除人工干预的需要，该框架使用脚本和错误检查来管理这个过程。"}]},{"ID":"20250513181055-vny9mz3","Type":"NodeList","ListData":{},"Properties":{"id":"20250513181055-vny9mz3","updated":"20250513181055"},"Children":[{"ID":"20250513181055-0hvwspv","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-0hvwspv","updated":"20250513181055"},"Children":[{"ID":"20250513181055-updm3qb","Type":"NodeParagraph","Properties":{"id":"20250513181055-updm3qb","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"测试转换"}]}]}]},{"ID":"20250513181055-z615uzv","Type":"NodeParagraph","Properties":{"id":"20250513181055-z615uzv","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"测试转换是指从一个性能测试切换到下一个性能测试的过程。测试转换的方法有很多种。最快的过渡方式是背靠背测试，即在完成上一个负载的测试后，开始加载新负载的应用程序。这种方法可以实现非常快的测试转换。然而，在一些情况下前一次测试的残余负载可能会干扰下一次测试。一种稍好的过渡方法是在性能测试之间增加一个延迟，从几秒到几分钟不等，这样剩余的负载就会流出系统。延迟的长度可以通过实验来确定。在实践中，采用基于启发式的过渡方法是可取的。该方法使用启发式方法，通过监测几个指标来确定剩余负载是否已经流出，以及系统是否已经达到空闲状态。例如，可以对应用程序资源进行检查，以确保直到应用程序机器的处理器利用率低于特定阈值(例如, 5 %)时，才触发下一次测试。"}]},{"ID":"20250513181055-o0ik2v2","Type":"NodeParagraph","Properties":{"id":"20250513181055-o0ik2v2","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"对于某些应用领域，前期测试数据如果不断积累，会影响后续测试的结果。例如，邮件服务器应用程序会不断地积累邮件，如果每次测试后邮件库没有被清理，那么邮件库的规模就会不断增加。随着邮件存储容量的不断增大，磁盘资源在后续的性能测试中可能会表现出迟滞的性能。应建立正规的归档程序。归档后，需要加载针对特定测试的新鲜测试数据。对于这样的应用程序，最好的方法是在每次测试之后对应用程序进行清理和重启。清理和重新启动方法将确保性能测试之间没有干扰。与前面的步骤类似，该框架通过模块化地调用执行这些转换任务的自定义例程来实现这些任务的自动化。"}]},{"ID":"20250513181055-pu0u5w0","Type":"NodeList","ListData":{},"Properties":{"id":"20250513181055-pu0u5w0","updated":"20250513181055"},"Children":[{"ID":"20250513181055-n0zy7fu","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-n0zy7fu","updated":"20250513181055"},"Children":[{"ID":"20250513181055-ykuysez","Type":"NodeParagraph","Properties":{"id":"20250513181055-ykuysez","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"测试分析"}]}]}]},{"ID":"20250513181055-p8aq75f","Type":"NodeParagraph","Properties":{"id":"20250513181055-p8aq75f","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"为避免误差，需要对每次试验的数据进行分析。由于产生的大量数据，手动分析性能计数器和应用程序日志可能是耗时、繁琐和重复的任务。我们的框架超越了以往的一步，不仅实现了错误分析的自动化，还将分析用于测试精简和模型构建。该框架在测试完成后自动触发结果分析。下面分节讨论了测试验证和指标分析的主要任务。"}]},{"ID":"20250513181055-g9rvjot","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20250513181055-g9rvjot","updated":"20250513181055"},"Children":[{"ID":"20250513181055-0abdnm9","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20250513181055-0abdnm9","updated":"20250513181055"},"Children":[{"ID":"20250513181055-3642g7s","Type":"NodeParagraph","Properties":{"id":"20250513181055-3642g7s","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"测试验证"}]}]}]},{"ID":"20250513181055-bbnu0t5","Type":"NodeParagraph","Properties":{"id":"20250513181055-bbnu0t5","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"在性能测试过程中，可能会出现一些问题。例如：(1) 功能缺陷，例如内存泄漏或执行效率低下，导致硬件资源在测试过程中向不稳定方向漂移。(2) 来自其他进程或应用程序的干扰，如自动下载和安装关键的操作系统补丁，或磁盘备份，这些进程会导致资源可用性的突然变化，并导致性能计数器的无效值。(3) 物理方面，比如数据中心机箱的工作温度上升，应用受到考验。这可能会导致无效的性能计数器。"}]},{"ID":"20250513181055-qqqhh5l","Type":"NodeParagraph","Properties":{"id":"20250513181055-qqqhh5l","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"这些问题使得性能测试数据无法用于分析和建模。为了检测这些问题，框架调用了验证例程，这些例程检查应用程序在性能测试过程中是否达到并保持稳定，以及所有计数器是否在其预期范围内。此外，对应用程序产生的日志进行挖掘，以检测应用程序中可能存在缺陷的任何执行异常。存在各种各样的日志挖掘技术来检测日志中的缺陷[ 5 ]。"}]},{"ID":"20250513181055-se3ndgg","Type":"NodeParagraph","Properties":{"id":"20250513181055-se3ndgg","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513181055-r7nlygz.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513181055-6nh0978","Type":"NodeParagraph","Properties":{"id":"20250513181055-6nh0978","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"检测不稳定性的一种简单方法是中心移动平均法，该方法过滤了短期波动，突出了长期趋势。图3中的不稳定性可以很容易地用这种方法从算法上检测出来。该方法表明，在整个测试过程中硬件资源的使用一直在增长，并且从未稳定。我们对DS2的验证模块的实现做了4种类型的验证："}]},{"ID":"20250513181055-t8gy16s","Type":"NodeList","ListData":{},"Properties":{"id":"20250513181055-t8gy16s","updated":"20250513181055"},"Children":[{"ID":"20250513181055-txywt47","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-txywt47","updated":"20250513181055"},"Children":[{"ID":"20250513181055-2gkbb0q","Type":"NodeParagraph","Properties":{"id":"20250513181055-2gkbb0q","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"如果在测试过程中应用程序达到并维持稳定状态，但某个资源的利用率在90 %以上，则我们将该测试标记为无法用于建模目的。究其原因，高利用率下的测量数据难以可靠、可重复[ 20 ]。此外，在比当前测试更高的设置下，所有预定的测试都跳过了(作为测试还原步骤的一部分)。该技术有助于避免在进行性能测试时由于应用程序过载而产生无效数据的浪费时间。"}]}]},{"ID":"20250513181055-57uvxnk","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-57uvxnk","updated":"20250513181055"},"Children":[{"ID":"20250513181055-8lx8l8e","Type":"NodeParagraph","Properties":{"id":"20250513181055-8lx8l8e","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"如果应用程序没有达到稳态(资源利用率呈现不断上升或不断下降的趋势)，那么我们将测试标记为无法用于建模目的。然而，与以前的情况不同，该框架在更高的工作负载设置下继续执行测试，因为当前测试中的不稳定性可能并不一定导致在更高的工作负载设置下的测试不稳定。"}]}]},{"ID":"20250513181055-31qh4v1","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-31qh4v1","updated":"20250513181055"},"Children":[{"ID":"20250513181055-a052q5l","Type":"NodeParagraph","Properties":{"id":"20250513181055-a052q5l","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"如果在(对于以前的或相同的构建/版本)之前执行了相同负载的性能测试，并且测量的指标(利用率、响应时间、吞吐量)有一个可配置的边界值，则该框架将当前测试标记为可能的坏运行。然后，业绩分析师可以对这种不良运行做进一步的分析。在解决了任何问题之后，框架可以运行增量式的建模测试，只执行先前标记的性能测试。"}]}]},{"ID":"20250513181055-h2exeap","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-h2exeap","updated":"20250513181055"},"Children":[{"ID":"20250513181055-gkmu68i","Type":"NodeParagraph","Properties":{"id":"20250513181055-gkmu68i","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"如果应用程序的日志在性能测试过程中显示出错误，那么我们将测试标记为无法用于建模目的。然而，该框架继续在较高的工作负载下执行测试。性能分析师可以推翻这一决定，并在建模中纳入该测试的结果，如果他们认为报告的错误不是性能关键。"}]}]}]},{"ID":"20250513181055-ktpx6ip","Type":"NodeParagraph","Properties":{"id":"20250513181055-ktpx6ip","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"所有的测试都由框架自动执行，并将结果呈现给性能分析人员。如果出现故障，可能需要人工调试才能找到测试失败的根本原因。一旦问题被修复，标记测试就可以重新运行。框架中的模块化和自动化允许重新运行所有或仅有的性能测试子集。"}]},{"ID":"20250513181055-w6xsd1g","Type":"NodeParagraph","Properties":{"id":"20250513181055-w6xsd1g","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"利用我们框架的验证步骤，我们在DS2应用程序中发现了一个死锁缺陷。应用服务器层将首先打开与数据库的连接，以便允许客户登录并查询其购买历史。然后应用程序将打开第二个连接，浏览客户历史记录中与标题相关的标题。在运行一个测试的几分钟内，应用服务器中的所有线程在捕获第一个连接后都会结束等待第二个连接。由于当前的MySQL驱动无法复用连接，我们修改了代码，使其不需要查询购买历史记录和相关标题。我们必须修复这个bug，以允许我们在显著高于先前为DS2建模的并发级别上进行性能测试。一旦我们修正了这个错误，我们就可以在更高的并发级别上进行建模"}]},{"ID":"20250513181055-so0jzba","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20250513181055-so0jzba","updated":"20250513181055"},"Children":[{"ID":"20250513181055-rm25pli","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20250513181055-rm25pli","updated":"20250513181055"},"Children":[{"ID":"20250513181055-nnau6rt","Type":"NodeParagraph","Properties":{"id":"20250513181055-nnau6rt","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"指标分析"}]}]}]},{"ID":"20250513181055-h9lz0g1","Type":"NodeParagraph","Properties":{"id":"20250513181055-h9lz0g1","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"对于每次性能测试，在预热和冷却期间收集的计数器都要从分析中修剪，而从稳态时间段收集的计数器则要进行分析。然后，在统计分析包中导入计数器，如R [ 24 ]、统计函数等。在性能建模研究中，传统的度量分析一直是一项繁琐的手工任务。我们通过创建框架调用的脚本模块来自动化这项任务。脚本对每次测试的预热和冷却期间捕获的性能计数器数据进行了剪切。我们在框架中保持预热和冷却时间的长度可配置，使其可以很容易地针对不同的应用进行定制。最后，该框架获得平均度量值，并将其存储在性能数据库(见图2)中，用于建模工作。"}]},{"ID":"20250513181055-dhotdr7","Type":"NodeParagraph","Properties":{"id":"20250513181055-dhotdr7","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"我们观察到，对于DS2的应用，十分钟的热身期足以达到稳态。由于加载工具的工作方式，DS2的冷却时间可以忽略不计。在实验的结束阶段，它并不对载荷进行下倾斜，而是在试验时间结束时将载荷从其确定的水平降至零。"}]},{"ID":"20250513181055-2d258kj","Type":"NodeList","ListData":{},"Properties":{"id":"20250513181055-2d258kj","updated":"20250513181055"},"Children":[{"ID":"20250513181055-yao1yhr","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181055-yao1yhr","updated":"20250513181055"},"Children":[{"ID":"20250513181055-ke1ylw8","Type":"NodeParagraph","Properties":{"id":"20250513181055-ke1ylw8","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"建模"}]}]}]},{"ID":"20250513181055-3l42n71","Type":"NodeParagraph","Properties":{"id":"20250513181055-3l42n71","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"在上一步中，该框架产生了不同工作负载规模下的性能指标。在这一步中，该框架调用了R [ 24 ]统计工具，该工具为应用程序的性能建立线性或非线性回归模型。图4展示了响应时间和处理器利用率之间的四阶回归模型的例子。一旦建立了回归模型，在任意负荷水平下的性能预测都是使用拟合模型完成的。为了全面讨论回归模型和预测技术，参见[ 4 ]，特别是第14章和第15章。开发的回归模型可以作为容量计算器的后端。"}]},{"ID":"20250513181055-d60uw5v","Type":"NodeParagraph","Properties":{"id":"20250513181055-d60uw5v","updated":"20250513181055"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513181055-7213bay.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]}]}