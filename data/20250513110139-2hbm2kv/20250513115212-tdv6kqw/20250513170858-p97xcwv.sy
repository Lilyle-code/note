{"ID":"20250513170858-p97xcwv","Spec":"1","Type":"NodeDocument","Properties":{"id":"20250513170858-p97xcwv","title":"2021-STVR-Performance Mutation Testing","type":"doc","updated":"20250513171545"},"Children":[{"ID":"20250513170908-dnepcbo","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513170908-dnepcbo","updated":"20250513170934"},"Children":[{"Type":"NodeText","Data":"摘要"}]},{"ID":"20250513170908-i220sp2","Type":"NodeParagraph","Properties":{"id":"20250513170908-i220sp2","updated":"20250513170934"},"Children":[{"Type":"NodeText","Data":"众所周知，性能错误是软件产品成功的主要威胁。性能测试旨在"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);"},"TextMarkType":"text","TextMarkTextContent":"通过测试用例执行程序并检查其是否表现出明显的性能下降来检测性能错误"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);\"}"},{"Type":"NodeText","Data":"。突变测试的原理是一种成熟的测试技术，通过注入人工故障来评估测试套件，可以用来评估和提高性能测试的检测能力。然而，应用突变测试来评估性能测试（以下称为性能突变测试（PMT））是一个新颖的研究课题，具有许多开放的挑战。在之前的论文中，我们确定了与 PMT 相关的一些关键挑战。在这项工作中，我们更进一步探索在通用语言的源代码级别应用 PMT 的可行性。为此，我们重新审视与经典突变测试相关的概念，并设计了七个新颖的突变算子来对已知的错误诱发模式进行建模。作为概念证明，我们将传统变异算子和性能变异算子应用于开源 C++ 程序。结果揭示了与传统突变体相比，新性能突变体有助于评估和增强性能测试的潜力。对这些程序中的活突变体的审查表明，它们可以诱导特殊测试输入的设计。除了这些有希望的结果之外，我们的工作还带来了与 PMT 相关的一系列全新挑战，这有望成为该领域新贡献的起点。"}]},{"ID":"20250513170908-uo6fgvb","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513170908-uo6fgvb","updated":"20250513171213"},"Children":[{"Type":"NodeText","Data":"INTRODUCTION"}]},{"ID":"20250513170908-7w9vpfa","Type":"NodeParagraph","Properties":{"id":"20250513170908-7w9vpfa","updated":"20250513170957"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);"},"TextMarkType":"text","TextMarkTextContent":"性能错误是可能导致性能显著下降的编程错误"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);\"}"},{"Type":"NodeText","Data":"，例如过度的内存消耗 [1] 或能量泄漏 [2， 3]。性能错误会影响程序的关键非功能性属性，例如执行时间或内存消耗。这些类型的 bug 非常有害，在已发布的软件程序中很常见 [4]，导致可用性差和资源浪费。这可能会导致用户流失、金钱损失，或者在最坏的情况下，导致人员伤亡，例如自动驾驶汽车没有及时制动。例如，最近的研究 [5， 6] 表明，40%的用户会离开加载时间超过 3 秒的网站，其中 8% 的用户会在性能不佳的网站中停止购买，或者 79% 的用户如果对访问效果不满意，则不太可能在同一网站上再次购买。因此，性能错误需要得到充分关注，以提高用户的忠诚度和系统的安全性。"}]},{"ID":"20250513170908-qm6orlr","Type":"NodeParagraph","Properties":{"id":"20250513170908-qm6orlr","updated":"20250513171131"},"Children":[{"Type":"NodeText","Data":"与功能故障相比，性能错误更难检测，并且需要更多的时间和精力来修复 [3]。这部分是由于缺乏测试 oracle，即决定给定输入下的程序性能是否可接受的机制，即 oracle 问题 [7， 8]。例如，"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);"},"TextMarkType":"text","TextMarkTextContent":"Nistor 等人 [3] 分析了来自三个成熟开源项目的 210 个性能错误，并得出结论“需要更好的预言机来发现性能错误”"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);\"}"},{"Type":"NodeText","Data":"。与"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);"},"TextMarkType":"text","TextMarkTextContent":"功能错误相反，性能错误通常不会在被测程序中产生错误的结果或崩溃，因此无法通过简单地检查程序输出来检测它们。此外，性能指标本质上是不确定的，并且由于许多因素（例如设备硬件、配置设置或当前工作负载）而可能因执行而异 [9]。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);\"}"},{"Type":"NodeText","Data":"例如，假设一个移动购物应用程序消耗 30Mb内存：这是预期的性能吗？应将其多少内存视为性能错误？这些类型的问题通常通过使用"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);"},"TextMarkType":"text","TextMarkTextContent":"执行分析器 [1， 10， 11]"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);\"}"},{"Type":"NodeText","Data":" 或"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);"},"TextMarkType":"text","TextMarkTextContent":"性能测试 [12， 13] "},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);\"}"},{"Type":"NodeText","Data":"来回答。还可以通过"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);"},"TextMarkType":"text","TextMarkTextContent":"搜索在目标的早期版本或相关程序中识别的诱发错误的模式 [7， 14， 15， 16] 来检测性能错误"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);\"}"},{"Type":"NodeText","Data":"。应用性能测试对于确信开发的系统没有性能故障（即性能方面的规范偏差）至关重要。请注意，这"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);"},"TextMarkType":"text","TextMarkTextContent":"与程序优化 [2， 17] 不同，程序优化的目标是提高程序的性能以实现更少的消耗"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);\"}"},{"Type":"NodeText","Data":"。 尽管这个问题具有相关性，但我们发现缺乏指导性能测试评估和改进的机制。"}]},{"ID":"20250513170908-hvnltkq","Type":"NodeParagraph","Properties":{"id":"20250513170908-hvnltkq","updated":"20250513170908"},"Children":[{"Type":"NodeText","Data":"突变测试是一种成熟的测试技术，用于评估和改进测试套件。在突变测试中，通过应用突变运算符生成目标程序的多个错误版本，即所谓的突变体。每个突变体都是通过对原始程序应用语法更改而生成的。然后，针对测试套件执行这些突变体，以评估其 faultrevealing 功能。某些突变体可能不会更改程序的语义，因此称为语义等效突变体。判断突变体是否等效是一个无法确定的问题，这是目前广泛采用突变测试的主要障碍之一 [18]。在大多数流行的编程语言中，已经提出了mutation 运算符的目录。然而，突变测试主要应用于功能测试，仍然作为一个有前途的开放研究课题适用于性能测试。以前关于突变测试和性能的论文在 Android [19] 或基于模型的突变运算符[20，21，22] 中定义了特定于域的突变运算符。在研究传统突变运算符解决非功能特性的适用性方面，也有一些初步工作 [23]。我们只找到了一篇论文，它引入了使用突变来推导出测试套件的想法，以估计最坏情况的执行时间 [24]。据我们所知，经典的突变测试方法尚未应用于在源代码级别注入影响程序性能的突变。"}]},{"ID":"20250513170908-kn0nr48","Type":"NodeParagraph","Properties":{"id":"20250513170908-kn0nr48","updated":"20250513170908"},"Children":[{"Type":"NodeText","Data":"在之前的短篇论文 [25， 26] 中，我们探讨了在性能级别应用突变测试的潜在好处和局限性，我们称之为性能突变测试 （PMT）。与经典的突变测试类似，PMT 的目标是生成原始程序的变体（性能突变体），其中每个变体都对性能错误进行建模，例如导致程序执行时间明显下降的错误。然后，这些人为的错误程序可用于评估和提高性能测试的有效性。然而，我们的初步结果表明，PMT 存在独特的问题，使其比功能层面的突变测试更具挑战性。例如，与功能突变测试相反，PMT 中的突变体应该表现出一定的性能下降，同时保留原始程序的语义。有趣的是，这意味着语义等效的突变体实际上是 PMT 的目标，而不是像传统突变那样成为障碍。这可能会导致编译优化技术出现问题，例如，如果它们检测到原始程序和突变体是等效的，则可能会自动撤消性能突变 [27]。"}]},{"ID":"20250513170908-j3461f9","Type":"NodeParagraph","Properties":{"id":"20250513170908-j3461f9","updated":"20250513171213"},"Children":[{"Type":"NodeText","Data":"在本文中，我们在研究 PMT 的可行性方面向前迈进了一步。特别是，我们首先根据文献中确定的经典性能错误模式提出了"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);"},"TextMarkType":"text","TextMarkTextContent":"七种性能突变运算符"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);\"}"},{"Type":"NodeText","Data":"[7，1，10，15，16，17，19，28，29]。然后，我们评估了它们在评估三个真实 C++ 程序中测试套件的故障检测能力方面的有效性。这要求我们重新审视有效、被杀死、活着和等效突变体的概念。在其他结果中，我们发现新算子比传统算子具有更大的潜力来模拟有用的性能故障。特别是，在被测程序中生成的超过 80% 的性能突变体（241 个中的194 个）没有被这些应用程序基于功能的测试套件检测到。这对性能突变体来说是一个积极的方面，因为根据定义，PMT 中使用的突变体应该保持程序的内部状态。相比之下，功能测试套件未检测到的传统突变体的百分比要低得多 （42.7%），这意味着在应用 PMT 时，超过一半的传统突变体被直接丢弃。我们通过从被测程序代码中提取的具体示例来说明 performance-mutants 的有用性。最后，我们提供了证据，证明大多数提议的突变并没有被编译器中实现的优化所抵消，这是这种方法可行性的必要条件。论文的结构如下。第 2 节回顾了性能错误和突变测试的最新技术。第 3 节激发了我们的工作，描述了 PMT 中的挑战，第 4 节提出了研究问题。 性能mutation 运算符的定义在 Section 5 中讨论。第6 节描述了实验评估，第 7 节分别显示和讨论了实验结果以回答研究问题。第 8 节和第 9 节分别对有效性和调查相关工作提出了威胁，这些工作侧重于突变测试和非功能特性。最后，第 10 节提出了结论和未来需要解决的未决研究问题。"}]},{"ID":"20250513170908-93tk3wr","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513170908-93tk3wr","updated":"20250513171304"},"Children":[{"Type":"NodeText","Data":"BACKGROUND"}]},{"ID":"20250513170908-6bn5j29","Type":"NodeList","ListData":{},"Properties":{"id":"20250513170908-6bn5j29","updated":"20250513171221"},"Children":[{"ID":"20250513170908-hv7b1ic","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513170908-hv7b1ic","updated":"20250513171221"},"Children":[{"ID":"20250513170908-ejk99ic","Type":"NodeParagraph","Properties":{"id":"20250513170908-ejk99ic","updated":"20250513171221"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"性能故障"}]}]}]},{"ID":"20250513170908-d8aacgr","Type":"NodeParagraph","Properties":{"id":"20250513170908-d8aacgr","updated":"20250513171250"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);"},"TextMarkType":"text","TextMarkTextContent":"当程序产生正确的结果，但其行为在性能方面明显下降时"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);\"}"},{"Type":"NodeText","Data":"，就会出现性能错误 [7，16]。因此，性能错误可以定义为导致性能显著下降的编程错误，主要是由于过度使用计算资源，如执行时间 [30]、内存 [1] 和能量 [2，3]。例如，考虑在 Groovy 中发现的真实性能错误，如图 1 所示。第4-7 行仅在数组 argT ypes 为null 或为空时才有意义。但是，这些行总是被执行，浪费计算资源。为了解决这个问题，在第 3 行中添加了一个 if 条件，以避免不必要地执行第 4-7 行[29]。根据 Jin 等人 [7] 的工作，有多种常见的根本原因经常导致性能错误，包括函数调用的低效组合、在某些上下文中不必要地使用函数或同步问题。经过充分测试的应用程序，如Microsoft SQLServer、Apache HTTPD 和Mozilla Firefox 等，会受到数百个性能错误的影响 [4， 3]。"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);"},"TextMarkType":"text","TextMarkTextContent":"性能错误可能会导致延迟、软件系统安全漏洞和不成比例的计算资源浪费"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);\"}"},{"Type":"NodeText","Data":"。由于这些原因，我们必须特别注意检测这类问题并重构代码以获得满足我们系统性能要求的版本。存在广泛使用的技术来检测和修复性能问题，例如使用分析器 [1， 10，11] 进行监督执行，或使用利用已知根本原因出现性能错误的错误检测策略 [7， 14， 15， 16]。 然而，性能 bug 在传统测试中通常被忽视，因为它们比功能 bug 更难暴露和检测，因为前者通常不会导致故障停止症状 [7]。关于性能测试的第一次有意义的研究可以追溯到90 年代 [12]。尽管在过去几年中人们对这一领域的兴趣越来越大 [13， 28，31， 32， 33]，但缺乏评估和改进性能测试有效性的机制，并且人们承认需要最复杂的性能测试策略 [8]。考虑到上述所有性能方面，性能 bug 的检测提出了许多需要解决的挑战。"}]},{"ID":"20250513170908-x4lgn1j","Type":"NodeParagraph","Properties":{"id":"20250513170908-x4lgn1j","updated":"20250513170908"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513170908-atb9j80.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513170908-nri0clx","Type":"NodeList","ListData":{},"Properties":{"id":"20250513170908-nri0clx","updated":"20250513171256"},"Children":[{"ID":"20250513170908-jlz13t9","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513170908-jlz13t9","updated":"20250513171256"},"Children":[{"ID":"20250513170908-nn54fda","Type":"NodeParagraph","Properties":{"id":"20250513170908-nn54fda","updated":"20250513171256"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"变异测试（Mutation testing）"}]}]}]},{"ID":"20250513170908-zlrf5g3","Type":"NodeParagraph","Properties":{"id":"20250513170908-zlrf5g3","updated":"20250513171304"},"Children":[{"Type":"NodeText","Data":"突变测试是一种结构测试方法，旨在"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);"},"TextMarkType":"text","TextMarkTextContent":"评估和提高测试套件在发现故障方面的有效性 "},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);\"}"},{"Type":"NodeText","Data":"[18]。为此，该技术通过许多预定义的规则（即mutation 运算符）注入故障（即 mutation），这些规则帮助我们衡量检测它们的测试套件的充分性。然后，针对测试套件执行程序的每个新版本（称为 mutants），以生成输出，其方式与原始程序相同。当测试用例检测到突变体（即突变体的输出与原始程序的输出不同）时，就说该突变体已被杀死。否则，突变体将保持活力。理想情况下，一个好的 mutation operator 应该产生不易检测的突变体，以便它们可以揭示测试套件中的弱点。相反，它应该最大限度地减少等效突变体的产生（即，没有可以揭示突变的输入）。等效突变体识别问题以及可以产生的大量突变体是更广泛地应用突变测试的两个绊脚石。这种测试技术过去曾用于测试不同级别的软件。突变测试已经在单元测试级别应用于许多编程语言（例如，Java [34]、C++ [35]、C# [36] 或 PHP [37] 等），并且也已用于集成级别 [38]。此外，我们可以找到一些建议在 Web 服务[39]、有限状态机 [40] 或定时自动机 [33， 41] 等应用中在规范级别使用突变测试的著作。"}]},{"ID":"20250513170908-8wuck0j","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513170908-8wuck0j","updated":"20250513171417"},"Children":[{"Type":"NodeText","Data":"PROBLEM STATEMENT"}]},{"ID":"20250513170908-kmeuviq","Type":"NodeParagraph","Properties":{"id":"20250513170908-kmeuviq","updated":"20250513171328"},"Children":[{"Type":"NodeText","Data":"性能突变测试 （PMT） 背后的问题可以定义为找到一组突变运算符，这些运算符允许评估和提高性能测试的故障检测效果。"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);"},"TextMarkType":"text","TextMarkTextContent":"每个 mutation 运算符都应该在程序的源代码中执行一次更改，这会导致性能明显下降，同时保留原始程序的功能。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);\"}"},{"Type":"NodeText","Data":"在这项工作中，我们将传统突变测试的应用移植到这个新领域，以评估性能测试的质量：就像功能测试评估程序与功能要求的合规性一样，性能测试表明程序与满足非功能规范的接近程度。由于通常无法获得此类规格，因此性能测试会评估被测程序是否偏离预期性能，即观察到性能显著下降。因此，目标是创建接近正确版本的程序错误版本，这与突变测试背后的两个经典假设一致：胜任程序员假说和耦合效应 [42]。前者也称为有限邻域假说 [43]，假设程序员有能力，因此他们倾向于编写接近理想版本的程序。在这个新领域中，重要的是要澄清这个理想的版本在性能方面并不是最佳程序（程序优化技术可能会有所帮助），但确实显示了预期的性能。后者，即耦合效应，指出足以识别简单更改引入的错误的测试也应该能够检测到更复杂的错误。 在本文中，我们假设这些原则适用于 PMT，因为它们适用于功能突变测试，基于文献中描述性能错误的现有工作。例如，Jin 等人 [7] 发现，大多数研究的性能错误都可以通过简单的更改来修复。可以说，引入性能错误的一种简单方法是在程序中的方便位置插入无害的延迟（例如，Thread.sleep（100））或强制不必要的资源消耗（例如，生成未使用的对象）。但是，尽管这种幼稚的方法在某些情况下可能会有所帮助，但它可能并不代表程序员引入的错误类型。Jin 等人 [7] 对109 个真实世界的性能错误进行了实证研究，得出的结论是，几乎 0% 的性能错误需要具有特殊特征的输入和大规模输入才能显现。同样，Liu et al. [15] 研究了 Android 应用程序中的 70 个实际性能错误，发现错误需要一定的输入序列才能被感知。因此，我们假设 mutation 引入的性能 bug 在理想情况下应该模仿程序员制造的典型性能 bug，而不是简单地综合消耗整个程序中的资源。"}]},{"ID":"20250513170908-9iknuvm","Type":"NodeParagraph","Properties":{"id":"20250513170908-9iknuvm","updated":"20250513170908"},"Children":[{"Type":"NodeText","Data":"在本文中，我们试图通过定义与域无关的突变运算符（因此适用于大多数编程语言）来评估和改进非功能测试套件来评估应用 PMT 的可行性。也就是说，我们的目标是回答以下与PMT 相关的研究问题："}]},{"ID":"20250513171349-w9ec3f3","Type":"NodeList","ListData":{},"Properties":{"id":"20250513171349-w9ec3f3","updated":"20250513171349"},"Children":[{"ID":"20250513171349-8i6d1mn","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513171349-8i6d1mn","updated":"20250513171349"},"Children":[{"ID":"20250513170908-oywyy3x","Type":"NodeParagraph","Properties":{"id":"20250513170908-oywyy3x","updated":"20250513171349"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"研究问题1：定义与域无关的性能突变运算符的可行性如何？"}]}]}]},{"ID":"20250513170908-a0rakgc","Type":"NodeParagraph","Properties":{"id":"20250513170908-a0rakgc","updated":"20250513170908"},"Children":[{"Type":"NodeText","Data":"在本研究中，我们旨在识别一些有用的错误模式，从而导致合理的性能错误（即，可能降低程序性能的模式），并研究它们在实际程序中的适用性。最近的一些论文提出了使用传统突变运算符与性能相关的可能性 [23， 25，44]。通过在我们的研究中引入传统算子，我们想阐明这些标准算子是否可以对性能错误进行建模，或者是否真的需要合并新的算子。为了研究使用传统算子进行 PMT 的可行性，我们解决了以下研究问题："}]},{"ID":"20250513170908-3cqei85","Type":"NodeList","ListData":{},"Properties":{"id":"20250513170908-3cqei85","updated":"20250513171355"},"Children":[{"ID":"20250513171352-it9yz1x","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513171352-it9yz1x","updated":"20250513171355"},"Children":[{"ID":"20250513171352-s4kmjof","Type":"NodeParagraph","Properties":{"id":"20250513171352-s4kmjof","updated":"20250513171355"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"研究问题2：传统算子生成的突变体中有多少百分比可以模拟性能错误？"}]}]}]},{"ID":"20250513170908-nh3ig6s","Type":"NodeParagraph","Properties":{"id":"20250513170908-nh3ig6s","updated":"20250513170908"},"Children":[{"Type":"NodeText","Data":"即使传统运算符为我们的目的产生了有效的突变体，了解专注于性能的新突变运算符是否比传统运算符更有效也是很有趣的。因此，我们的目标是回答以下问题："}]},{"ID":"20250513170908-4caxax6","Type":"NodeList","ListData":{},"Properties":{"id":"20250513170908-4caxax6","updated":"20250513171401"},"Children":[{"ID":"20250513171358-e2l1s3w","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513171358-e2l1s3w","updated":"20250513171401"},"Children":[{"ID":"20250513171358-2khb74o","Type":"NodeParagraph","Properties":{"id":"20250513171358-2khb74o","updated":"20250513171401"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"研究问题3：性能突变算子产生多少性能突变体，这些突变体改变功能行为的频率如何"},{"Type":"NodeText","Data":"？"}]}]}]},{"ID":"20250513170908-ernflea","Type":"NodeParagraph","Properties":{"id":"20250513170908-ernflea","updated":"20250513170908"},"Children":[{"Type":"NodeText","Data":"一旦针对测试套件执行了这些性能突变体，我们想知道这些有效的性能突变体是否能够导致可察觉的性能下降，以及检测它们所需的测试输入类型。这是下一个问题的目的："}]},{"ID":"20250513170908-35jybx7","Type":"NodeList","ListData":{},"Properties":{"id":"20250513170908-35jybx7","updated":"20250513171408"},"Children":[{"ID":"20250513171405-vamms7k","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513171405-vamms7k","updated":"20250513171408"},"Children":[{"ID":"20250513171405-h9keyk6","Type":"NodeParagraph","Properties":{"id":"20250513171405-h9keyk6","updated":"20250513171408"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"研究问题4：定义的性能算子是否能够对一些明显的性能下降进行建模？"}]}]}]},{"ID":"20250513170908-7oa22hm","Type":"NodeParagraph","Properties":{"id":"20250513170908-7oa22hm","updated":"20250513170908"},"Children":[{"Type":"NodeText","Data":"最后，在之前的工作中，我们注意到了 PMT 与编译器中实现的优化之间的联系。更具体地说，我们观察到编译器优化和性能突变都旨在保留程序的功能，因此，前者执行的转换可能会撤消后者。因此，我们用以下问题完成研究："}]},{"ID":"20250513170908-a82ofod","Type":"NodeList","ListData":{},"Properties":{"id":"20250513170908-a82ofod","updated":"20250513171417"},"Children":[{"ID":"20250513171414-3zuwsu5","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513171414-3zuwsu5","updated":"20250513171417"},"Children":[{"ID":"20250513171414-q1wh8i8","Type":"NodeParagraph","Properties":{"id":"20250513171414-q1wh8i8","updated":"20250513171417"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"研究问题5：编译器执行的优化能否恢复注入性能突变运算符的突变？"}]}]}]},{"ID":"20250513170908-h5sbngg","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513170908-h5sbngg","updated":"20250513171545"},"Children":[{"Type":"NodeText","Data":"PERFORMANCE MUTATION OPERATORS"}]},{"ID":"20250513170908-itip9im","Type":"NodeParagraph","Properties":{"id":"20250513170908-itip9im","updated":"20250513170908"},"Children":[{"Type":"NodeText","Data":"为了解决RQ1 问题，我们首先寻找真实的性能错误模式，这些模式会激发我们定义与性能相关的 mutation 运算符。因此，我们描述了一组突变运算符，这些运算符利用了文献中观察到的性能下降的常见原因。我们还研究了应用这些运算符以生成有效突变体的条件。为了降低问题的复杂性可行性研究侧重于通用语言功能和非并发程序（突变可能导致同步问题）。特别是，我们总共定义了7 个性能突变运算符，它们都影响了大多数通用编程语言中存在的基本编程功能（例如，循环、条件语句、容器、对象等）。一般来说，应该可以使这些 mutation 运算符适应每种特定语言的具体语法。事实上，其中一些运算符是根据特定于领域的运算符（例如，Android 应用程序）定义的。在大多数情况下，传统突变测试的应用很简单，因为我们只需要避免无效突变体（即语法不正确的突变体）的产生。这一事实在 PMT 的情况下是不同的，因为如前所述，性能突变体应该在保留其功能的同时降低被测程序的一个或多个非功能属性。为了同时实现这两个目标，通常需要对源代码进行预处理。这有助于防止已知会改变程序语义的琐碎情况。为了说明这一点，请考虑图 2 中由突变运算符 Swap of Operands in Condition(Swap of Operands in Condition)或 SOC 生成的性能突变体示例（稍后在第 5.4 节中定义）。此运算符交换条件语句中的条件顺序，目的是强制始终计算最耗时的条件。"}]},{"ID":"20250513170908-p8teqr5","Type":"NodeParagraph","Properties":{"id":"20250513170908-p8teqr5","updated":"20250513170908"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513170908-aev96ax.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513170908-15upmnt","Type":"NodeParagraph","Properties":{"id":"20250513170908-15upmnt","updated":"20250513170908"},"Children":[{"Type":"NodeText","Data":"如图所示，当 obj 为 null 时，此更改将导致功能问题，因为我们无法在 null 对象上调用方法。我们通过为 mutation 运算符定义适当的前提条件来解决这个问题。在这一点上需要注意的是，前提条件旨在避免注入修改程序功能的性能突变，但我们不能总是保证语义被保留。对于每个 mutation 运算符，我们接下来描述其动机、定义、示例和其应用的一组前提条件。表I 总结了已定义的 mutation 运算符的主要特征。"}]},{"ID":"20250513170908-92mjhdd","Type":"NodeParagraph","Properties":{"id":"20250513170908-92mjhdd","updated":"20250513170908"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513170908-3h9f22d.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513170908-zmjutde","Type":"NodeList","ListData":{},"Properties":{"id":"20250513170908-zmjutde","updated":"20250513171545"},"Children":[{"ID":"20250513170908-wzzg79w","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513170908-wzzg79w","updated":"20250513171545"},"Children":[{"ID":"20250513170908-l550m72","Type":"NodeParagraph","Properties":{"id":"20250513170908-l550m72","updated":"20250513171545"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Rcl：去除回路中的停止条件"}]},{"ID":"20250513171439-2qud3bb","Type":"NodeList","ListData":{},"Properties":{"id":"20250513171439-2qud3bb","updated":"20250513171532"},"Children":[{"ID":"20250513170908-uxbjt4r","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513170908-uxbjt4r","updated":"20250513170908"},"Children":[{"ID":"20250513170908-emdn70e","Type":"NodeParagraph","Properties":{"id":"20250513170908-emdn70e","updated":"20250513170908"},"Children":[{"Type":"NodeText","Data":"动机：根据 Jin 等人 [7] 的说法，当调用函数时会发生可跳过函数错误模式，但考虑到调用上下文，这是不必要的。同样，有时我们可以配置一个循环，在满足某个条件时停止，从而节省一些不影响程序结果的不必要的迭代。对此，Nistor 等人 [29] 确定了一系列与循环和条件相关的性能错误，这些错误具有 CondBreak 修复，即可以通过在循环内添加条件来修复的错误。第 2 节中所示的图 1 描述了这种性能错误的示例。"}]}]},{"ID":"20250513170908-4ce6d9u","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513170908-4ce6d9u","updated":"20250513171532"},"Children":[{"ID":"20250513170908-f2mlkxw","Type":"NodeParagraph","Properties":{"id":"20250513170908-f2mlkxw","updated":"20250513171532"},"Children":[{"Type":"NodeText","Data":"定义：受此错误模式的启发，RCL 运算符在循环中删除了停止条件，以便循环不断迭代，直到满足另一个条件。这是通过不同的方式实现的，即:"}]}]}]}]}]},{"ID":"20250513170908-7n1ec15","Type":"NodeParagraph","Properties":{"id":"20250513170908-7n1ec15","updated":"20250513170908"},"Children":[{"Type":"NodeText","Data":" \t\t1）\t 删除break 语句，"}]},{"ID":"20250513170908-6633wxp","Type":"NodeParagraph","Properties":{"id":"20250513170908-6633wxp","updated":"20250513170908"},"Children":[{"Type":"NodeText","Data":"\t\t2） 延迟 true 或false 的 return 语句，"}]},{"ID":"20250513170908-oz119l1","Type":"NodeParagraph","Properties":{"id":"20250513170908-oz119l1","updated":"20250513170908"},"Children":[{"Type":"NodeText","Data":"\t\t3） 删除使用明确定义的布尔变量在满足停止条件时停止循环执行的条件。"}]},{"ID":"20250513171502-tih78to","Type":"NodeList","ListData":{},"Properties":{"id":"20250513171502-tih78to","updated":"20250513171513"},"Children":[{"ID":"20250513171503-y93s92d","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513171503-y93s92d","updated":"20250513171513"},"Children":[{"ID":"20250513171503-fchhnd6","Type":"NodeParagraph","Properties":{"id":"20250513171503-fchhnd6","updated":"20250513171503"},"Children":[{"Type":"NodeText","Data":"示例：以下代码片段显示了应用 RCL 运算符的第三个选项。该突变体从 while 循环中删除第二个条件 （！b），使程序在第一个条件的计算结果为 true （i \u003c n） 时进行迭代。但是，在 l[i] == 1."}]}]}]},{"ID":"20250513170908-uivl490","Type":"NodeList","ListData":{},"Properties":{"id":"20250513170908-uivl490","updated":"20250513170908"},"Children":[{"ID":"20250513170908-e6rntz2","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513170908-e6rntz2","updated":"20250513170908"},"Children":[{"ID":"20250513170908-b1ztwjp","Type":"NodeParagraph","Properties":{"id":"20250513170908-b1ztwjp","updated":"20250513170908"},"Children":[{"Type":"NodeText","Data":"前提条件： 当有其他条件可以在某个时候停止循环时，可以生成 RCL 性能突变。当循环的控制表达式不为空（情况 1 和 2）或循环的控制表达式中存在多个条件（情况 3）时，会发生这种情况。"}]}]}]}]}