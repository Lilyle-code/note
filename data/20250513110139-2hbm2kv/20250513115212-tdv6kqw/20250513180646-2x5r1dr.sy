{"ID":"20250513180646-2x5r1dr","Spec":"1","Type":"NodeDocument","Properties":{"id":"20250513180646-2x5r1dr","title":"2015-TSE-The Oracle Problem in Software Testing: A Survey","type":"doc","updated":"20250513181308"},"Children":[{"ID":"20250513180654-njs49br","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513180654-njs49br","updated":"20250513181308"},"Children":[{"Type":"NodeText","Data":"摘要"}]},{"ID":"20250513181305-zy2wdlg","Type":"NodeParagraph","Properties":{"id":"20250513181305-zy2wdlg","updated":"20250513181308"}},{"ID":"20250513181305-xwlkjdh","Type":"NodeParagraph","Properties":{"id":"20250513181305-xwlkjdh","updated":"20250513181305"},"Children":[{"Type":"NodeText","Data":"测试具有随机输出的软件是一项具有挑战性的任务，因为与给定输入对应的输出因执行而异。因此，通常的软件测试方法不适用于随机化软件。相反，已经提出了统计假设检验来测试这些应用程序。要应用这些统计假设检验，需要了解程序输出的统计特征的理论值（例如平均值）或参考实施（例如遗留系统）来应用统计假设检验。但通常，两者都不可用。在本文中，讨论了如何在不知道确切的理论特征或具有参考实现的情况下使用一种称为 Metamorphic Testing 的测试方法来构建统计假设检验。为此，被测实现 （IUT） 生成两个或多个独立的输出序列。然后，使用统计假设检验根据关系对这些序列进行比较。"}]},{"ID":"20250513181305-79kdvvd","Type":"NodeParagraph","Properties":{"id":"20250513181305-79kdvvd","updated":"20250513181305"},"Children":[{"Type":"NodeText","Data":"Introduction"}]},{"ID":"20250513181305-8xnrimd","Type":"NodeParagraph","Properties":{"id":"20250513181305-8xnrimd","updated":"20250513181305"},"Children":[{"Type":"NodeText","Data":"随机仿真是一种广泛使用的解决问题的工具。例如，股票市场在金融数学中被模拟，以便能够计算各种金融衍生品的价格或检查投资策略。在电信基础设施的背景下，复杂的随机模型用于模拟电信网络。基于这些模拟，我们计划对基础设施进行进一步投资。尽管大量使用仿真技术（并依赖于其结果），但这些程序只是偶尔进行测试。"}]},{"ID":"20250513181305-l3bz3sa","Type":"NodeParagraph","Properties":{"id":"20250513181305-l3bz3sa","updated":"20250513181305"},"Children":[{"Type":"NodeText","Data":"原因之一是随机软件（即具有随机输出的程序）（例如随机模拟）很难测试，因为此类程序在多次运行时通常会为相同的输入参数生成不同的输出。因此，不能应用经典的测试方法，因为它们通常要求单个输入对应于一个输出（始终相同）。统计假设检验已被提出作为这个问题的解决方案 [6， 9， 10， 11]。复杂模拟程序 [11]、图像处理算法 [9， 10]、空间统计程序和数值程序[6] 已通过统计假设检验进行了测试。"}]},{"ID":"20250513181305-sxt2b3d","Type":"NodeParagraph","Properties":{"id":"20250513181305-sxt2b3d","updated":"20250513181305"},"Children":[{"Type":"NodeText","Data":"使用统计方法至少需要一些关于随机输出的知识。需要输出统计特征的理论值，或者需要参考实现。但这并不总是对测试人员可用。本文提出了一种新的方法。对于这种方法，只需要了解相关执行（即 input 参数彼此相关的执行）的 output 分布的关系。这种关于分布的 “相对” 知识比 “绝对” 知识更容易获得。"}]},{"ID":"20250513181305-uw6gats","Type":"NodeParagraph","Properties":{"id":"20250513181305-uw6gats","updated":"20250513181305"},"Children":[{"Type":"NodeText","Data":"Preliminaries"}]},{"ID":"20250513181305-q4lqmus","Type":"NodeList","ListData":{},"Properties":{"id":"20250513181305-q4lqmus","updated":"20250513181305"},"Children":[{"ID":"20250513181305-6cvnzt6","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181305-6cvnzt6","updated":"20250513181305"},"Children":[{"ID":"20250513181305-8f75p0r","Type":"NodeParagraph","Properties":{"id":"20250513181305-8f75p0r","updated":"20250513181305"},"Children":[{"Type":"NodeText","Data":"统计假设测试"}]}]}]},{"ID":"20250513181305-o9u3kjh","Type":"NodeParagraph","Properties":{"id":"20250513181305-o9u3kjh","updated":"20250513181305"},"Children":[{"Type":"NodeText","Data":"随机软件测试背后的基本思想是将规范 S 和程序 P 的输出建模为随机变量 [7]。然后，确定程序是否符合其规范的问题等同于确定两个随机变量是否等效的问题。在统计学中，存在几个随机变量相等的概念。我们将使用基于分布相等性的定义，用 S 和 P 的 S d =P 表示。为了进行统计假设检验，必须指定两个假设，即原假设和替代假设。然后，测试是否拒绝 null 假设。在我们的例子中，原假设被选择为“P 符合 S”。但是，由于很难将整个分布的 P 与 S 进行比较，因此通常会比较两个随机变量的均值。均值相等通常是原假设。统计假设检验基于 IUT 的一个或多个输出序列。这些序列称为样本。为这些样本计算一个函数，即所谓的检验统计量。如果检验统计量的值不在某个区间（置信区间）内，则原假设将被拒绝，并且检验将失败。统计假设的决策与两种类型的误差有关。如果 IUT 正确但失败，则会出现 I 型错误或 α 错误，而如果IUT 虽然有缺陷但通过测试，则会发生 II 型错误（或 β 错误）。在软件测试的上下文中，类型 II 错误显然是更重要的错误。但通常，只能提前确定 I 类错误的概率。 在 [9， 10] 中，提出了一种统计检验方法，该方法允许预先指定上述II 类误差的概率。通过重复，可以减少两种错误概率。在本文中，需要比较两个样本的测试。在 [6] 中，提出了两个比较软件测试的均值和所谓的线性可变性的测试。"}]},{"ID":"20250513181305-xwjxbt9","Type":"NodeParagraph","Properties":{"id":"20250513181305-xwjxbt9","updated":"20250513181305"},"Children":[{"Type":"NodeText","Data":"Statistical Metamorphic Testing"}]},{"ID":"20250513181305-aol3n2j","Type":"NodeParagraph","Properties":{"id":"20250513181305-aol3n2j","updated":"20250513181305"},"Children":[{"Type":"NodeText","Data":"如前所述，基于统计假设检验 [6， 9， 10， 11] 的随机软件测试方法要么需要有关程序输出的理论分布的知识，要么需要参考实现。 通常，这个要求没有得到满足。因此，统计检验似乎不适用。我们提出了统计假设检验和蜕变检验的组合。基本思想是通过对 IUT 输出的每个样本使用不同的输入参数，从 IUT 生成两个或多个样本（即输出序列）。输入关系 RI 定义应如何生成这些样本，即它定义用于不同样本的输入参数的关系。输出关系 RO 描述了这些样本在统计上如何相互关联。通常，仅指定多个样本的分布如何相关，而无需指定它们的确切分布，这通常要简单得多。为了应用统计假设检验，所有样本都必须在统计上独立。对于具有随机输出的确定性程序，必须为每个样本独立生成输入。"}]},{"ID":"20250513181305-6jyuq2v","Type":"NodeList","ListData":{},"Properties":{"id":"20250513181305-6jyuq2v","updated":"20250513181305"},"Children":[{"ID":"20250513181305-iv9u02q","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181305-iv9u02q","updated":"20250513181305"},"Children":[{"ID":"20250513181305-g08xod1","Type":"NodeParagraph","Properties":{"id":"20250513181305-g08xod1","updated":"20250513181305"},"Children":[{"Type":"NodeText","Data":"Illustrating Example"}]}]}]},{"ID":"20250513181305-hqbuuys","Type":"NodeParagraph","Properties":{"id":"20250513181305-hqbuuys","updated":"20250513181305"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513181305-ux309po.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513181305-0u07bqp","Type":"NodeParagraph","Properties":{"id":"20250513181305-0u07bqp","updated":"20250513181305"},"Children":[{"Type":"NodeText","Data":"为了说明该方法，我们在下面提供一个示例。在 [6] 中，提出了一个基于随机马赛克（所谓的镶嵌）模拟算法的案例研究。马赛克的示例图像如图 1 所示。这种马赛克特征的理论公式（例如，每单位面积的单元格数或每单位面积的边数）仅对某些简单的马赛克类型已知。如果马赛克更复杂，这些理论公式就很难获得。然而，可以发现使用不同输入参数生成的样本之间的一些简单属性，即使对于复杂类型的马赛克，这些属性也可以用作统计关系。在这里，IUT 的输出是一个对象，表示采样窗口中随机马赛克的实现。在图 1 中，采样窗口是一个正方形。IUT 需要两个输入参数，第一个参数控制随机马赛克的强度，第二个参数指定采样窗口。由于很难直接比较 IUT 的不同输出，因此在测试中只考虑马赛克的某些特征。这种特征的一个例子是每单位面积的像元数。IUT 的一个特性是马赛克的特征不取决于观察窗的大小（和形状）。因此，对于测试，将生成两个具有不同大小和/或形状的观察窗口样本。算法的第一个参数在两个样本中是相同的。然后，通过统计假设检验两个样本的特征分布是否相等来检验。实际上，我们只能检验特征的均值和变异性是否相等。 从简单的马赛克中可以知道，每单位面积的平均细胞数仅取决于强度。根据经验，强度加倍应使平均细胞数增加四倍。对于复杂的马赛克，此属性仍应成立。因此，第二个有用的属性导致了以下策略：生成两个样本，一个样本的强度为 γ，第二个样本的强度为 kγ （k \u003e 0， k 6= 1）。然后，通过统计假设检验 k2 乘以第一个样本的细胞数是否等于第二个样本的细胞数，检验它们的平均值和变异性。这是可用于测试随机马赛克模拟的第二个统计关系。图 2 说明了该方法。IUT 用于生成具有不同参数设置的两个输出数据序列。然后，分析器 （A） 提取输出的某些特征，从而为每个程序输出序列生成一个（实数）序列。最后，统计假设检验（例如第 4 节中介绍的那些）用于确定数字序列在统计上是否相等。"}]},{"ID":"20250513181305-qnsl0y7","Type":"NodeList","ListData":{},"Properties":{"id":"20250513181305-qnsl0y7","updated":"20250513181305"},"Children":[{"ID":"20250513181305-yqcqpjn","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181305-yqcqpjn","updated":"20250513181305"},"Children":[{"ID":"20250513181305-jgmgwnq","Type":"NodeParagraph","Properties":{"id":"20250513181305-jgmgwnq","updated":"20250513181305"},"Children":[{"Type":"NodeText","Data":"A More Detailed Description of the Proposed Approach"}]}]}]},{"ID":"20250513181305-tpxhbaj","Type":"NodeParagraph","Properties":{"id":"20250513181305-tpxhbaj","updated":"20250513181305"},"Children":[{"Type":"NodeText","Data":"在所提出的方法中，输入关系描述了如何获得两个或多个样本，即输出数据的序列。它要么描述随机软件的输入参数的确定性关系，要么描述确定性 IUT 的随机输入的统计关系。output relation 描述了不同参数化 output 之间的统计关系。通过使用相同的输入参数执行IUT n 次（在随机软件的情况下和独立随机测试数据的情况下，在确定性软件的情况下）获得具有相同参数化的输出样本。通常，输出关系应该是统计假设检验的原假设，或者应从中派生原假设。因此，统计关系的输出关系（与关系的输出关系）使用的表示法略有不同。最简单的统计关系使用两个样本，这些样本的生成使得（以某种方式）转换的程序输出对于 RI ⊂ I2 给出的参数化分布相同。从形式上讲，这可以用关系RO 来描述：f （P （i1）） d = g（P （i2）），其中f （·） 和 g（·） 是转换输出的可测量函数。前面例子的统计关系属于这一类，其中f （·） 和 g（·） 是恒等式或线性函数 f （x） = k2x，P 是输出的特征（例如每单位面积的细胞数）。统计关系中涉及的样本数量没有限制。例如，考虑一个具有两个输入 μ 和 σ2 的随机程序 N，它生成具有相应参数的正态分布输出。 那么 N （μ1， σ2 1）+N（μ2， σ2 2）d = N （μ1 +μ2， σ2 1+ σ2 2） 显然根据高斯分布的性质成立。这需要生成 N 输出的三个独立样本。然后，添加前两个样本的单个输出，以获得组合样本。此后，将这个 “组合样本” 与第三个样本进行比较（在上述公式的右侧）。请注意，获取程序输出的独立样本非常重要，以便大多数统计假设检验适用。"}]},{"ID":"20250513181305-hr0m18s","Type":"NodeList","ListData":{},"Properties":{"id":"20250513181305-hr0m18s","updated":"20250513181305"},"Children":[{"ID":"20250513181305-54rrztl","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513181305-54rrztl","updated":"20250513181305"},"Children":[{"ID":"20250513181305-4eih8wr","Type":"NodeParagraph","Properties":{"id":"20250513181305-4eih8wr","updated":"20250513181305"},"Children":[{"Type":"NodeText","Data":"Steps of the Proposed Approach"}]}]}]},{"ID":"20250513181305-i7jaxo6","Type":"NodeParagraph","Properties":{"id":"20250513181305-i7jaxo6","updated":"20250513181305"},"Children":[{"Type":"NodeText","Data":"所提出的方法包括以下步骤（统计假设检验的部分在[6]中详细说明）："}]},{"ID":"20250513181305-m00ibl1","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20250513181305-m00ibl1","updated":"20250513181305"},"Children":[{"ID":"20250513181305-q2fe8mn","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20250513181305-q2fe8mn","updated":"20250513181305"},"Children":[{"ID":"20250513181305-999t967","Type":"NodeParagraph","Properties":{"id":"20250513181305-999t967","updated":"20250513181305"},"Children":[{"Type":"NodeText","Data":"选择 RI、RO、错误概率α、样本大小 N 以及重复次数 R（R 必须是奇数）。"}]}]},{"ID":"20250513181305-06ou1i0","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20250513181305-06ou1i0","updated":"20250513181305"},"Children":[{"ID":"20250513181305-33qhufl","Type":"NodeParagraph","Properties":{"id":"20250513181305-33qhufl","updated":"20250513181305"},"Children":[{"Type":"NodeText","Data":"根据 RI 生成参数设置（i1，…，in）。"}]}]},{"ID":"20250513181305-6mx4lss","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20250513181305-6mx4lss","updated":"20250513181305"},"Children":[{"ID":"20250513181305-92hnizf","Type":"NodeParagraph","Properties":{"id":"20250513181305-92hnizf","updated":"20250513181305"},"Children":[{"Type":"NodeText","Data":"生成样本 X1 "},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"="}]},{"Type":"NodeText","Data":" (x1,1，…，x1,N)，…，XN "},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"="}]},{"Type":"NodeText","Data":" (xn,1，…，xn,N)。样本 Xk 由 N 个独立的程序输出组成，每个输出都有输入参数 ik（1 ≤ k ≤ n）。"}]}]},{"ID":"20250513181305-udgttot","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20250513181305-udgttot","updated":"20250513181305"},"Children":[{"ID":"20250513181305-l80ul8c","Type":"NodeParagraph","Properties":{"id":"20250513181305-l80ul8c","updated":"20250513181305"},"Children":[{"Type":"NodeText","Data":"进行统计假设检验，以决定是否需要拒绝样本 X1，…，XN 中的 RO。"}]}]},{"ID":"20250513181305-fk3f0nx","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NS4=","Num":5},"Properties":{"id":"20250513181305-fk3f0nx","updated":"20250513181305"},"Children":[{"ID":"20250513181305-4qifs9t","Type":"NodeParagraph","Properties":{"id":"20250513181305-4qifs9t","updated":"20250513181305"},"Children":[{"Type":"NodeText","Data":"只要迭代次数少于 R，就回到步骤 3。"}]}]},{"ID":"20250513181305-ldntn6f","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Ni4=","Num":6},"Properties":{"id":"20250513181305-ldntn6f","updated":"20250513181305"},"Children":[{"ID":"20250513181305-bggu576","Type":"NodeParagraph","Properties":{"id":"20250513181305-bggu576","updated":"20250513181305"},"Children":[{"Type":"NodeText","Data":"如果在大多数情况下统计假设检验的零假设（即 RO 成立）没有被拒绝，则 IUT 通过测试。"}]}]}]},{"ID":"20250513181305-scbgt5b","Type":"NodeParagraph","Properties":{"id":"20250513181305-scbgt5b","updated":"20250513181305"},"Children":[{"Type":"NodeText","Data":"A first Case Study"}]},{"ID":"20250513181305-o6j5d6o","Type":"NodeParagraph","Properties":{"id":"20250513181305-o6j5d6o","updated":"20250513181305"},"Children":[{"Type":"NodeText","Data":"在本节中，提出了一个简单的案例研究来证明该方法的实际适用性。该研究的主题是取自 [8] 的正态分布 Φ-1 的逆累积分布函数的实现。IUT由90 个LOC 组成。MuJava 工具用于生成 306 个突变体。使用三种不同的测试技术对这些突变体进行了检查：针对原始实现的确定性测试、针对原始实现的相等均值和相等线性变异性的统计假设检验（如 [6] 所示）以及新的统计变形测试方法。如果在测试中使用关系生成的样本时，拒绝相等均值或相等线性变异性的检验的零假设，则称突变体被统计变形关系杀死。为了获得正确的决定，每个测试重复 R = 871 次。函数 Φ−1 只需要一个参数 0 ≤ p ≤ 1。如果选择在区间 [0， 1] 上均匀分布的参数，则 Φ−1（p） 是正态分布的随机变量。因此，在研究中的任何测试中，输入都是随机均匀分布在[0，1] 上生成的。选择该计划有几个原因。首先，可以应用不同的测试技术，然后可以通过它们杀死突变体的能力进行比较。其次，IUT 直接生成数字作为输出。否则，将必须计算一些特征，并且它们的计算可能会影响测试方法的效率。但是，所提出的统计变形测试方法并不要求程序本身是随机的，只要求输出必须是随机的。该选择的缺点是缺少参数。 因此，只确定了一种关系。如果参数 p 在区间[0，1] 上均匀分布，则认为 aΦ−1（p） + bΦ−1（p） d = √a2 + b2Φ−1（p）。为简单起见，我们在研究中选择了 a = 3 和 b = 4。在统计测试的同时，使用与统计测试相同的（随机）输入，通过直接比较突变体的输出和原始实现来测试突变体。对于任何样本量，256 个突变体被杀死，其中 77 个通过引发异常。对突变源代码的更仔细检查表明，未被杀死的 50 个突变体要么是真正等效的（35 个突变体），要么揭示错误的概率几乎等于 0。在图 3 中，显示了针对原始实施和新的统计变形测试方法的统计假设检验杀死的突变体数量。横坐标描述了样本量 n，被杀死的突变体的数量显示在纵坐标上。对于这两种方法，对于大 n，被杀死的突变体的数量都稳定下来。对于任何样本量 n，使用统计假设检验（针对原始实现）的方法比统计变形检验方法杀死更多的突变体。对于 n 足够大，基于统计假设检验的测试杀死了 224 个 （85.5%） 突变体，而194 个 （75.8%） 突变体被新方法杀死。统计假设检验方法无法杀死的突变体大多计算与 Φ-1完全不同的函数，但这些其他函数不会影响突变体输出的分布特性。 由于统计假设检验只能检验样本是否具有相同的分布特性，因此这种方法无法杀死这些突变体中的任何一个。这可以解释为另一种程序等价，即统计程序等价。对这些未被新方法杀死但被统计假设检验方法杀死的突变体的更仔细检查表明，30 个突变体中有 24 个与原始实现不同，仅在靠近输入空间边界的地方。由于这些突变体的结构相似，用于测试的关系很可能不适合检测这种故障。其余 6 个突变体与原始实现仅略有不同，因此很难杀死。为了用统计假设检验杀死这六个突变体，需要一个大样本量（至少 n = 3000）。样本量的进一步增加也可能导致所提议的方法被杀死。在案例研究中，只使用了单一的关系。正如变质测试中的研究表明的那样，不同关系的组合可以改善结果。不幸的是，我们无法确定 IUT 的其他关系，因此，我们无法证明这也适用于统计测试。由于大多数未被统计测试方法杀死的突变体具有相似的结构，因此所选的关系可能无法检测到故障。此外，不可能根据现有数据给出任何关于选择良好统计关系的提示。大样本量似乎是所提出的方法的实际限制。但在这里，只需要大约 30 秒的执行时间来测试 n = 5000 和 R = 871 的突变体"}]},{"ID":"20250513180654-fx5fowz","Type":"NodeParagraph","Properties":{"id":"20250513180654-fx5fowz","updated":"20250513180654"},"Children":[{"Type":"NodeText","Data":"测试涉及检查系统的行为以发现潜在故障。给定一个系统的输入，区分相应的期望、正确行为与潜在不正确行为的问题被称为“测试预言问题”。测试预言自动化对于消除阻碍更大范围测试自动化的瓶颈至关重要。没有测试预言自动化，人类必须确定观察到的行为是否正确。关于测试预言的文献介绍了预言自动化的技术，包括建模、规范、契约驱动开发和蜕变测试。当这些都不完全足够时，测试预言信息的最终来源仍然是人类，他们可能了解非正式规范、期望、规范和特定领域的信息，这些信息提供了非正式预言指导。所有形式的测试预言，即使是谦虚的人类，都涉及降低成本和增加收益的挑战。本文提供了对当前测试预言问题方法的全面调查，以及对软件测试研究和实践这一重要领域趋势的分析。"}]}]}