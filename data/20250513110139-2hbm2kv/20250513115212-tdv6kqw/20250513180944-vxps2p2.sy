{"ID":"20250513180944-vxps2p2","Spec":"1","Type":"NodeDocument","Properties":{"id":"20250513180944-vxps2p2","title":"2012-ICSE-Automatically Finding Performance Problems with Feedback-Directed Learning Software Testing","type":"doc","updated":"20250513181011"},"Children":[{"ID":"20250513180944-0yxqxi6","Type":"NodeParagraph","Properties":{"id":"20250513180944-0yxqxi6","updated":"20250513180954"},"Children":[{"Type":"NodeText","Data":"（总结：一种测试用例选择策略）"}]},{"ID":"20250513180958-pcbi10g","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513180958-pcbi10g","updated":"20250513181002"},"Children":[{"Type":"NodeText","Data":"摘要"}]},{"ID":"20250513180958-234deh5","Type":"NodeParagraph","Properties":{"id":"20250513180958-234deh5","updated":"20250513180958"},"Children":[{"Type":"NodeText","Data":"性能测试的目标是发现应用程序对于某些输入值组合意外表现出恶化特性的情况。性能测试的一个基本问题是如何更快地选择输入数据的可管理子集以自动发现应用程序中的性能问题。我们提供了一种新颖的解决方案，可以使用黑盒软件测试自动发现应用程序中的性能问题。我们的解决方案是一个自适应的、反馈导向的学习测试系统，它从应用程序的执行轨迹中学习规则，然后使用这些规则自动为这些应用程序选择测试输入数据，与探索性随机测试相比，可以发现更多的性能问题。我们已经实施了我们的解决方案，并将其应用于一家大型保险公司的中型应用程序和开源应用程序。性能问题是自动发现的，并由经验丰富的测试人员和开发人员确认。"}]},{"ID":"20250513180958-idmxpon","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513180958-idmxpon","updated":"20250513181005"},"Children":[{"Type":"NodeText","Data":"Background"}]},{"ID":"20250513180958-udvjt5v","Type":"NodeParagraph","Properties":{"id":"20250513180958-udvjt5v","updated":"20250513180958"},"Children":[{"Type":"NodeText","Data":"当运行许多不同的测试用例并观察应用程序的行为时，测试人员直观地感觉到测试用例的某些属性可能会揭示性能错误。将这些属性自动提取为描述这些属性如何影响应用程序性能的规则是我们方法的子目标。"}]},{"ID":"20250513180958-ed2vben","Type":"NodeParagraph","Properties":{"id":"20250513180958-ed2vben","updated":"20250513180958"},"Children":[{"Type":"NodeText","Data":"选择能够高效捕获性能问题的测试输入数据的规则很困难，因为这些规则隐藏在源代码中，因此很难手动定位。测试工程师必须深入了解被测应用程序的功能，了解程序员如何设计和实现该应用程序，并假设应用程序行为如何与该应用程序的需求相匹配。如果没有总结这些需求的有用规则，就很难定义导致选择良好测试用例的目标[14]。目前，寻找有用规则的实践现状是利用性能测试工程师的经验和直觉，他们在运行手动构建的测试用例时花时间观察 AUT 的行为。对于发现性能测试问题几乎没有自动化支持，Hassan 等人最近的一项工作是第一个可以通过分析性能日志来自动检测负载测试结果中的性能问题[3]，但是无法找到导致性能问题的测试输入。经验和直觉是性能测试工程师用来推测可能错误的主要工具[15][13]。"}]},{"ID":"20250513180958-x2rq5um","Type":"NodeList","ListData":{},"Properties":{"id":"20250513180958-x2rq5um","updated":"20250513180958"},"Children":[{"ID":"20250513180958-gkx40fk","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180958-gkx40fk","updated":"20250513180958"},"Children":[{"ID":"20250513180958-q3yed27","Type":"NodeParagraph","Properties":{"id":"20250513180958-q3yed27","updated":"20250513180958"},"Children":[{"Type":"NodeText","Data":"自动化性能测试脚本"}]}]}]},{"ID":"20250513180958-ldf8uab","Type":"NodeParagraph","Properties":{"id":"20250513180958-ldf8uab","updated":"20250513180958"},"Children":[{"Type":"NodeText","Data":"通常，性能测试是使用测试脚本完成的，测试脚本是测试工程师编写的用于自动化测试的程序。这些测试脚本执行操作（即调用公开接口的方法或模仿 AUT 的 GUI 对象上的用户操作）以将输入数据馈送到 AUT 并触发计算。测试工程师在测试脚本中编写代码，指导测试输入的选择；通常，它是使用随机选择的输入值或使用组合设计交互算法来完成的[16]。没有测试脚本就不可能对应用程序进行性能测试，因为让数十万测试人员模拟多个用户手动高频调用多个方法是不可行的[17][18][19][1]。测试脚本使用两种不同的框架之一编写：GUI 测试框架（例如 HP 公司的 QuickTestPro）或后端服务器控制的性能工具，例如 JMeter，这是一种广泛用于负载测试功能行为和测量的开源软件应用程序的性能。这些框架是工业中大部分性能测试的基础。性能测试脚本模拟大量用户以在 AUT 上创建显着负载。 JMeter 提供的编程结构使测试人员能够自动生成大量虚拟用户，这些用户直接向 AUT 的 Web 服务器发送 HTTP 请求，从而产生大量工作负载。性能的自然衡量标准包括吞吐量，即每秒执行的请求数和执行请求所需的平均响应时间。 性能测试的目标是确定哪些请求组合会导致更长的响应时间和更低的吞吐量，这有助于揭示 AUT 中的性能错误。"}]},{"ID":"20250513180958-6haaa8t","Type":"NodeList","ListData":{},"Properties":{"id":"20250513180958-6haaa8t","updated":"20250513180958"},"Children":[{"ID":"20250513180958-qs70s5d","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180958-qs70s5d","updated":"20250513180958"},"Children":[{"ID":"20250513180958-zlytzja","Type":"NodeParagraph","Properties":{"id":"20250513180958-zlytzja","updated":"20250513180958"},"Children":[{"Type":"NodeText","Data":"问题陈述"}]}]}]},{"ID":"20250513180958-hmjawjx","Type":"NodeParagraph","Properties":{"id":"20250513180958-hmjawjx","updated":"20250513180958"},"Children":[{"Type":"NodeText","Data":"我们的目标是通过对一小组随机选择的测试输入数据执行 AUT，然后高精度地推断规则来自动选择测试输入数据，从而在 AUT 中发自动发现性能问题。具体来说，这些是描述输入数据属性的 if-then 规则，这些属性会产生良好的性能测试用例，与计算工作量小得多时的不良性能测试用例相比，这些测试用例会导致应用程序的计算工作量增加。例如，规则可能会说“如果输入 convictedFraud 为 true 并且 deadboltInstalled 为 false，则测试用例是好的。”"}]},{"ID":"20250513180958-i6gvmw5","Type":"NodeParagraph","Properties":{"id":"20250513180958-i6gvmw5","updated":"20250513180958"},"Children":[{"Type":"NodeText","Data":"在这项工作中，我们使用反馈机制提供自动学习的规则来测试脚本，这些脚本解析这些规则并使用它们自动指导测试输入数据选择，以引导 AUT 的执行针对暴露性能问题的代码。在本文中，我们接受什么构成良好测试用例的性能测试定义。一般来说，性能测试的一个主要目标是选择一小部分“好的”测试用例，通过这些测试用例可以实现不同的测试目标[14]，具体来说，可以在更短的时间内发现更多的性能问题。"}]},{"ID":"20250513180958-fcg5lqc","Type":"NodeParagraph","Properties":{"id":"20250513180958-fcg5lqc","updated":"20250513180958"},"Children":[{"Type":"NodeText","Data":"性能测试的目标之一是找到导致 AUT 的响应时间或吞吐量或其延迟恶化的测试用例。它可以通过向 AUT 添加更多用户从而导致密集计算和增加计算工作负载以及通过查找使 AUT 需要更多资源和时间来计算结果的输入数据来实现。相反，糟糕的测试用例是那些与良好的测试用例相比，使用很少的资源并且执行时间要少得多的测试用例。 主要目标是自动生成描述好和坏测试用例的规则，然后使用这些规则，同时自动选择输入数据以进行进一步测试。系统还应该通过将学习的规则应用于使用这些规则选择的测试输入数据并验证这些测试数据是否导致预测的性能结果来进行自我纠正，从而增加学习的规则表达输入值和性能相关之间的真正因果关系的概率工作负载，而不是简单地将它们关联起来。最后，如果不向性能工程师提供 AUT 中可能潜藏问题的足够线索，任何性能测试都是不完整的。性能分析的一个主要目标是找到瓶颈——使用分析器很容易检测到拖累整个应用程序性能的单一方法；然而，当有数百个方法的执行时间大致相同时，找到瓶颈是一个困难的问题，这在大规模应用程序中经常出现[11]，[12]。我们在本文中解决的一个问题是，一旦使用学习规则将输入空间聚类为良好和不良性能测试用例，我们希望找到特定于良好性能测试用例并且最有可能造成瓶颈的方法。"}]},{"ID":"20250513180958-187uiyo","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513180958-187uiyo","updated":"20250513181011"},"Children":[{"Type":"NodeText","Data":"Forest方法"}]},{"ID":"20250513180958-j4igmlz","Type":"NodeParagraph","Properties":{"id":"20250513180958-j4igmlz","updated":"20250513180958"},"Children":[{"Type":"NodeText","Data":"在本节中，我们将描述构建 FOREPOST 的两个关键思想："}]},{"ID":"20250513180958-uy749db","Type":"NodeList","ListData":{},"Properties":{"id":"20250513180958-uy749db","updated":"20250513180958"},"Children":[{"ID":"20250513180958-wnqpds8","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180958-wnqpds8","updated":"20250513180958"},"Children":[{"ID":"20250513180958-iajr670","Type":"NodeParagraph","Properties":{"id":"20250513180958-iajr670","updated":"20250513180958"},"Children":[{"Type":"NodeText","Data":"从执行跟踪中提取规则，这些规则描述输入数据的属性与使用此数据执行的性能测试工作负载之间的关系。"}]}]},{"ID":"20250513180958-zxpm6vw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180958-zxpm6vw","updated":"20250513180958"},"Children":[{"ID":"20250513180958-vamf4pk","Type":"NodeParagraph","Properties":{"id":"20250513180958-vamf4pk","updated":"20250513180958"},"Children":[{"Type":"NodeText","Data":"使用这些规则识别瓶颈方法。"}]}]}]},{"ID":"20250513180958-06rkcxn","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20250513180958-06rkcxn","updated":"20250513180958"},"Children":[{"ID":"20250513180958-p4euwyy","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20250513180958-p4euwyy","updated":"20250513180958"},"Children":[{"ID":"20250513180958-k4z2la3","Type":"NodeParagraph","Properties":{"id":"20250513180958-k4z2la3","updated":"20250513180958"},"Children":[{"Type":"NodeText","Data":"获取规则"}]}]}]},{"ID":"20250513180958-fo1qtyo","Type":"NodeParagraph","Properties":{"id":"20250513180958-fo1qtyo","updated":"20250513180958"},"Children":[{"Type":"NodeText","Data":"作为第一个关键思想的一部分，插桩的 AUT 最初使用少量随机选择的测试输入数据运行，其执行配置文件使用机器学习 （ML） 技术自动收集并聚类到不同的组中，这些组共同描述 AUT 的不同性能结果。例如，可以有两组对应于好和坏性能测试用例。用于良好和不良测试用例的 AUT 输入值集是 ML 分类算法的输入。此输入被描述为VI1 ， . . . ，VIk → T 的形式，其中 VIm 是输入 Im 和 T ∈ {G， B}的值， G 和 B 分别代表好和坏测试用例。实际上，T 是执行跟踪的汇总分数，它简要描述此执行是否有性能问题的证据。ML 分类算法学习模型并输出格式为 Ip ⊙ VIp • Iq ⊙ VIq • . . . • Ik ⊙ VIk → T ，其中 ⊙ 是关系运算符之一， • 代表逻辑连接器 and 和 or。这些规则有助于指导在测试脚本中选择输入测试数据。通过将使用 ML 分类算法获取的这些学习规则反馈回测试脚本中，以自动指导测试输入数据的选择，从而形成反馈循环。使用新学习的规则，对测试输入数据进行分区，并重复循环。 测试脚本从不同的分区中选择输入，再次执行 AUD，并从收集的执行跟踪中重新学习新规则。如果在测试一段时间后没有学习到新规则，则意味着测试输入的分区是稳定的，概率很高。此时，可以删除插桩并继续测试，并使用学习的规则选择测试输入数据。"}]},{"ID":"20250513180958-8wxp3j5","Type":"NodeParagraph","Properties":{"id":"20250513180958-8wxp3j5","updated":"20250513180958"},"Children":[{"Type":"NodeText","Data":"2） 识别瓶颈"}]},{"ID":"20250513180958-1rzqfer","Type":"NodeParagraph","Properties":{"id":"20250513180958-1rzqfer","updated":"20250513180958"},"Children":[{"Type":"NodeText","Data":"我们的目标是帮助测试工程师自动识别瓶颈，因为其执行严重影响整个 AUT 的性能。例如，考虑一个线程定期执行的方法，用于检查某个文件的内容是否被修改。虽然此方法可能是瓶颈之一，但它在好的和坏的测试用例中都会被调用，因此它作为应用程序逻辑的必要部分对资源消耗的贡献不会带来任何可能解决性能问题的见解。我们的第二个关键思想是考虑在好的测试用例中出现的最重要的方法，而这些方法在坏的测试用例中没有被调用或几乎没有意义，其中方法的重要性是其执行触发的资源消耗的函数"}]},{"ID":"20250513180958-wsqa5y1","Type":"NodeParagraph","Properties":{"id":"20250513180958-wsqa5y1","updated":"20250513180958"},"Children":[{"Type":"NodeText","Data":"FOREPOST 方法"}]},{"ID":"20250513180958-ng5281d","Type":"NodeParagraph","Properties":{"id":"20250513180958-ng5281d","updated":"20250513180958"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513180958-0razfha.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513180958-ecphb2a","Type":"NodeParagraph","Properties":{"id":"20250513180958-ecphb2a","updated":"20250513180958"},"Children":[{"Type":"NodeText","Data":"FOREPOST 的架构如图 2 所示。实线箭头显示组件之间的命令和数据流，圆圈中的数字表示工作流程中的操作顺序。工作流程的开头用粗箭头显示，表示测试脚本通过模拟用户并调用 AUT 接口的方法来执行应用程序。测试脚本由测试工程师编写 (1)，作为自动化应用程序测试的一部分，如我们在第 II-C 节中所述。一旦测试脚本开始执行应用程序，探查器就会收集 (2) 其执行跟踪，并将这些跟踪转发到执行跟踪分析器，后者会生成 (3) 跟踪统计信息。我们使用TPTP 框架实现了 Profiler。此统计信息包含有关每个跟踪的信息，例如调用的方法的数量、完成端到端应用程序运行所需的时间、线程的数量以及在此跟踪中调用的唯一方法的数量。轨迹统计数据被提供 (4) 到轨迹聚类模块，该模块使用 ML 算法 JRip [25] 将这些轨迹执行无监督聚类，分为两组，分别对应于 (6) 良好和 (5) 不良测试轨迹。用户可以查看聚类结果，并且 (7) 如果需要，可以重新分配聚类轨迹。这些聚类轨迹被提供 (8) 给学习器，学习器使用它们来学习分类模型和 (9) 我们在第 III-A 节中描述的输出规则。如果用户有足够的证据，用户可以查看 (10) 这些规则并将其中一些规则标记为错误。然后将规则提供给测试脚本 (11)。 一旦测试脚本收到一组新的规则，它就会根据这些规则将输入空间划分为块，并通过从每个块中选择一个输入来开始形成测试输入。探查器收集这些新测试运行的痕迹，因此循环重复，每几次都可以学习新规则，并且输入空间会自适应地重新分区以适应这些规则。我们使用Weka [26] 实现了 FOREPOST 的 ML 部分。输入测试数据来自现有存储库或数据库；这是业界的常见做法，我们与不同的性能测试专业人员证实了这一点。回想一下，Renters 应用程序有一个包含大约 7800 万个客户资料的数据库，这些数据库用作包括 Renters 本身在内的不同应用程序的测试输入数据。我们使用从输入空间中随机选择的初始种子重复运行实验，每次都不同。如果规则不可用，则从输入空间中随机选择新值，或者基于学习的规则选择新值。最后，回顾第 II-D 节，一旦输入空间被划分为导致好和坏测试用例的集群，我们希望找到特定于良好性能测试用例并且最有可能导致瓶颈的方法。该任务与计算规则并行完成，并且在跟踪分析器生成 (12) 用于构造 (13) 两个矩阵 ‖ xB ‖ 和 ‖ xG ‖ 的方法和数据统计（14）坏和好时开始。相应的测试用例。构建这些矩阵的方法如我们在第 III-C 节中所述。一旦构建了这些矩阵，ICA 就会将它们（15）分解为相应的坏测试用例和好测试用例的矩阵 ‖ sB ‖ 和 ‖ sG ‖。 回想一下，我们的关键思想是考虑在良好的测试用例中出现的最重要的方法，而这些方法在不良的测试用例中不会被调用或几乎没有意义。通过交叉引用指定不同要求的方法权重的矩阵“sB”和“sG”，顾问 (16) 确定性能测试人员应该查看的最佳方法 (17) 以调试可能的性能问题。此步骤完成了 FOREPOST 的工作流程。"}]}]}