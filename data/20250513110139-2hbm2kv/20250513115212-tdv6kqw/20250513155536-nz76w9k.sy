{"ID":"20250513155536-nz76w9k","Spec":"1","Type":"NodeDocument","Properties":{"id":"20250513155536-nz76w9k","title":"2023-TSE-A Large-Scale Empirical Study of Real-Life Performance Issues in Open Source Projects","type":"doc","updated":"20250513155923"},"Children":[{"ID":"20250513155545-1s1x7q0","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513155545-1s1x7q0","updated":"20250513155622"},"Children":[{"Type":"NodeText","Data":"摘要"}]},{"ID":"20250513155545-xytjz5k","Type":"NodeParagraph","Properties":{"id":"20250513155545-xytjz5k","updated":"20250513155615"},"Children":[{"Type":"NodeText","Data":"软件性能是一个决定软件系统成功与否的关键质量属性。然而，从业者缺乏对从技术、工程和经济角度如何在实际中引起和解决现实生活中的性能问题的全面和整体理解。本文对来自 13 个开源项目、涵盖各种问题领域、用三种流行编程语言Java（192 个问题）、C/C++（162 个问题）和 Python（216 个问题）实现的大规模实证研究进行了介绍。从技术角度来看，我们"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);"},"TextMarkType":"text","TextMarkTextContent":"总结了适用于所有三种语言的八种一般性能问题类型及其相应的根本原因和解决方案。我们还从文献中确定了检测和解决不同类型问题的可用工具"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);\"}"},{"Type":"NodeText","Data":"。此外，我们发现 570 个问题中有 27%是通过设计级别的优化——一组相关源文件及其设计结构的协调修订来解决的。 我们揭示了四个典型的设计级优化模式，包括经典设计模式、变更传播、优化克隆和并行优化，这些模式是实践者在解决性能问题时应该注意的。从工程角度来看，这项研究分析了测试代码在性能优化中的变化。我们发现，在 570 个性能问题中，只有 15%涉及测试代码的修订。在大多数情况下，修订的测试用例集中在性能优化的功能逻辑上，而不是直接评估性能改进。这一发现指向了在回归测试中正式验证性能优化的潜在工程标准不足。最后，从经济角度来看，我们分析了性能优化的“投资回报率”。我们发现，设计级优化通常需要更多的投资，但并不总是带来更高的性能改进。然而，当开发者关注其他质量属性，如可维护性和可读性时，他们倾向于使用设计级优化。"}]},{"ID":"20250513155621-7yq9ddv","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513155621-7yq9ddv","updated":"20250513155923"},"Children":[{"Type":"NodeText","Data":"Introduction"}]},{"ID":"20250513155545-42le0r8","Type":"NodeParagraph","Properties":{"id":"20250513155545-42le0r8","updated":"20250513155545"},"Children":[{"Type":"NodeText","Data":"软件性能是运行时通过系统的及时性、响应性和资源消耗来衡量的关键质量属性[1]，[2]，[3]，[4]，[5]。性能问题可能导致严重后果，包括预算超支、项目延误和市场损失[1]，[4]。尽管有众多先前研究调查了现实生活性能问题的原因和解决方案[4]，[6]，[7]，[8]，[9]，从业者仍然缺乏对性能问题从技术、工程和经济角度引起的、解决的和测试的全面和整体理解。"}]},{"ID":"20250513155545-qkreoy3","Type":"NodeParagraph","Properties":{"id":"20250513155545-qkreoy3","updated":"20250513155700"},"Children":[{"Type":"NodeText","Data":"首先，从技术角度来看，从业者仍然缺乏对常见类型性能问题和它们各自解决方案的全面视野。一方面，大多数现有研究"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);"},"TextMarkType":"text","TextMarkTextContent":"专注于特定类型的性能问题"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);\"}"},{"Type":"NodeText","Data":"。例如，一个研究得很好的性能问题是由于"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);"},"TextMarkType":"text","TextMarkTextContent":"低效的循环迭代"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);\"}"},{"Type":"NodeText","Data":"[10]，[11]，[12]，[13]，[14]。另一方面，少数实证研究[4]，[6]"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);"},"TextMarkType":"text","TextMarkTextContent":"揭示了常见性能问题的分类"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);\"}"},{"Type":"NodeText","Data":"，这些研究基于相对较小的数据集——例如。 仅对[4]和[6]中分别研究的 100 和 109 个性能问题进行了调查。它们通常关注特定的编程语言或特定的软件项目领域，例如 JavaScript[9]或 Android 智能手机应用[7]、[8]。本研究旨在基于包含 570 个真实性能问题的更大规模数据集，对不同类型的性能问题提供一个全面的概述。这些问题来自三个流行的编程语言（Java、Python、C/C++）的开源项目。这使得分析编程语言对实践中性能问题原因和解决方案的影响成为可能。"}]},{"ID":"20250513155545-8kvltnu","Type":"NodeParagraph","Properties":{"id":"20250513155545-8kvltnu","updated":"20250513155748"},"Children":[{"Type":"NodeText","Data":"此外，在现有文献中，性能问题通常通过代码级别的修复来解决，例如在一个源文件中对几行代码进行修订[10]、[13]。然而，实践者经常遇到具有架构根源的性能问题，包括无意中使用架构性能反模式，例如导致硬件或软件对象过载焦点的神级类[15]。据我们所知，我们是第一个从"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);"},"TextMarkType":"text","TextMarkTextContent":"设计角度"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);\"}"},{"Type":"NodeText","Data":"研究性能优化的。 更具体地说，我们将性能优化分为两种一般类型：;"}]},{"ID":"20250513155545-vpsu8p3","Type":"NodeList","ListData":{},"Properties":{"id":"20250513155545-vpsu8p3","updated":"20250513155738"},"Children":[{"ID":"20250513155725-wxy1qad","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513155725-wxy1qad","updated":"20250513155738"},"Children":[{"ID":"20250513155725-7g96v8o","Type":"NodeParagraph","Properties":{"id":"20250513155725-7g96v8o","updated":"20250513155738"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"局部优化："},{"Type":"NodeText","Data":"通过在单个源文件中用几行代码实现；"}]}]}]},{"ID":"20250513155545-c9k822x","Type":"NodeList","ListData":{},"Properties":{"id":"20250513155545-c9k822x","updated":"20250513155740"},"Children":[{"ID":"20250513155727-z32geow","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513155727-z32geow","updated":"20250513155740"},"Children":[{"ID":"20250513155727-ga3yxga","Type":"NodeParagraph","Properties":{"id":"20250513155727-ga3yxga","updated":"20250513155740"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"设计级优化："},{"Type":"NodeText","Data":"涉及对一组相关源文件及其设计结构的协调修订。"}]}]}]},{"ID":"20250513155545-04kj2wf","Type":"NodeParagraph","Properties":{"id":"20250513155545-04kj2wf","updated":"20250513155803"},"Children":[{"Type":"NodeText","Data":"局部优化的典型例子是通过添加一行检查条件来“中断”循环，以解决低效迭代的修复。而设计级优化的典型例子是解决 AVRO-753 问题[16]（在第 5 节中详细讨论）。对于特殊输入类型，程序会变得非常慢。在解决过程中，开发者采用了工厂设计模式来分离和封装处理不同输入类型的算法到不同的工厂中。如果没有工厂设计模式，将会有一个潜在的上帝类，它承担着处理所有输入类型的责任。在本研究中，我们揭示了"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);"},"TextMarkType":"text","TextMarkTextContent":"在解决性能问题时典型的设计级优化模式"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20250513155545-weylcss","Type":"NodeParagraph","Properties":{"id":"20250513155545-weylcss","updated":"20250513155828"},"Children":[{"Type":"NodeText","Data":"此外，从工程角度来看，软件测试是现代软件工程流程中不可分割的一部分，尤其是对于敏捷方法[1]、[17]、[18]、[19]。实践者通常依靠测试用例在发布产品之前识别性能问题[2]、[19]。因此，测试也应该是性能优化中的一个基本方面。然而，关于性能优化是否以及如何导致相关测试用例的修订，了解甚少。本研究通过"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);"},"TextMarkType":"text","TextMarkTextContent":"全面分析性能优化中出现的测试-生产协同变更模式"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);\"}"},{"Type":"NodeText","Data":"来填补这一空白。目标是提供见解，使实践者将性能优化和测试视为一个综合任务。最后，在实践上，软件开发受限于有限的时间和资源。然而，大多数现有工作仅从纯粹的技术角度处理性能问题，而没有考虑解决性能问题的经济因素。为了填补这一空白，本研究评估了我们数据集中每个性能问题的投资回报率（ROI）。 作为投资的代理，我们衡量参与的开发者数量和解决每个问题的讨论数量。至于回报，我们衡量修复每个问题后性能改进的程度。此外，我们认为性能优化也可能涉及其他长期收益，如设计质量和代码可维护性。棘手的是，这些收益大多难以衡量。因此，当开发者解决性能问题时，我们从他们的讨论和评论中提取相关信息。我们比较本地化和设计级别优化解决方案的 ROI，以提供在实际中优先考虑不同优化策略的目的。"}]},{"ID":"20250513155545-2z3dh1f","Type":"NodeParagraph","Properties":{"id":"20250513155545-2z3dh1f","updated":"20250513155914"},"Children":[{"Type":"NodeText","Data":"本研究通过四个研究问题，填补了实践者对现实生活性能问题的理解上的上述空白："}]},{"ID":"20250513155545-70r70m7","Type":"NodeList","ListData":{},"Properties":{"id":"20250513155545-70r70m7","updated":"20250513155905"},"Children":[{"ID":"20250513155545-l415z07","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513155545-l415z07","updated":"20250513155853"},"Children":[{"ID":"20250513155545-sdqg77c","Type":"NodeParagraph","Properties":{"id":"20250513155545-sdqg77c","updated":"20250513155853"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"RQ1 - 性能问题的常见根本原因和解决方法是什么"},{"Type":"NodeText","Data":"？我们根据以三种常用语言（Java、Python 和 C/C++）实现的开源项目中的 570 个实际性能问题，对常见类型的性能问题进行了总结和分类。我们还进行了广泛的文献综述，以查找用于检测和修复相关性能问题的可用工具。我们对调查编程语言对性能问题的影响特别感兴趣。"}]}]},{"ID":"20250513155545-uiy1bww","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513155545-uiy1bww","updated":"20250513155858"},"Children":[{"ID":"20250513155545-5ugkq2q","Type":"NodeParagraph","Properties":{"id":"20250513155545-5ugkq2q","updated":"20250513155858"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"RQ2 - 设计级优化是否以及如何解决性能问题？"},{"Type":"NodeText","Data":"我们首先展示通过设计级优化解决数据集中的性能问题的频率。接下来，我们揭示了常见的设计级优化模式，以及为什么它们对于解决某些性能问题是必需的。特别是，我们感兴趣的是了解不同编程语言中的问题是否 design-level optimization patterns 不同。"}]}]},{"ID":"20250513155545-ryapruv","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513155545-ryapruv","updated":"20250513155901"},"Children":[{"ID":"20250513155545-446u865","Type":"NodeParagraph","Properties":{"id":"20250513155545-446u865","updated":"20250513155901"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"RQ3 - 测试代码是否以及如何随性能优化而变化？"},{"Type":"NodeText","Data":"我们首先测量开发人员在性能优化中修改测试代码的频率。接下来，我们研究修订后的测试代码和生产代码在多大程度上相互关联，以及性能优化中的测试-生产协同变化模式是什么。"}]}]},{"ID":"20250513155545-bdlo799","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513155545-bdlo799","updated":"20250513155905"},"Children":[{"ID":"20250513155545-zdz1voj","Type":"NodeParagraph","Properties":{"id":"20250513155545-zdz1voj","updated":"20250513155905"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"RQ4 - 修复性能问题的投资回报率是多少？"},{"Type":"NodeText","Data":"我们的目标是比较本地化和设计级优化的 ROI。此外，我们还研究了不同编程语言的性能优化的 ROI 是否以及如何不同。"}]}]}]},{"ID":"20250513155545-ur099cz","Type":"NodeParagraph","Properties":{"id":"20250513155545-ur099cz","updated":"20250513155545"},"Children":[{"Type":"NodeText","Data":"本研究在以下几个方面为关注软件性能的从业者提供了独到的见解："}]},{"ID":"20250513155545-f00veon","Type":"NodeList","ListData":{},"Properties":{"id":"20250513155545-f00veon","updated":"20250513155545"},"Children":[{"ID":"20250513155545-r4dpwjj","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513155545-r4dpwjj","updated":"20250513155545"},"Children":[{"ID":"20250513155545-vkow3fe","Type":"NodeParagraph","Properties":{"id":"20250513155545-vkow3fe","updated":"20250513155545"},"Children":[{"Type":"NodeText","Data":"根本原因：我们总结了实际性能问题的8 个常见根本原因，这些问题对三种编程语言都是通用的，并为从业者提供了全面的概述。开发人员可能会从专注于不同根本原因的现有工具中受益，但这些工具的可用性和可用性可能是一个问题。"}]}]},{"ID":"20250513155545-j58eyy2","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513155545-j58eyy2","updated":"20250513155545"},"Children":[{"ID":"20250513155545-uy0z0ms","Type":"NodeParagraph","Properties":{"id":"20250513155545-uy0z0ms","updated":"20250513155545"},"Children":[{"Type":"NodeText","Data":"设计级优化：尽管编程语言不同，但实际性能问题中的重要部分需要设计级优化。我们总结了四种类型的设计级优化模式，包括1） 经典模式，2） 更改传播，3） 优化克隆，以及 4） 并行优化。这为从业者提供了如何在设计层面解决性能问题的实证见解。"}]}]},{"ID":"20250513155545-lxhbbck","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513155545-lxhbbck","updated":"20250513155545"},"Children":[{"ID":"20250513155545-v5go30m","Type":"NodeParagraph","Properties":{"id":"20250513155545-v5go30m","updated":"20250513155545"},"Children":[{"Type":"NodeText","Data":"测试/生产代码协同变更：只有 15% 的性能问题涉及测试代码修订。从这些问题中，我们发现了五种测试-生产协同交换模式，包括 1） 方法替换，2） 性能输入修订，3） 测试逻辑修改，4） 测试用例添加，以及 5） 测试文件添加。在这 5 种模式中，只有 Performance Input Revision 模式直接针对验证程序在不同输入下的性能，而其他四种模式则通过关注修订后的生产代码的功能逻辑来间接验证性能优化的有效性。因此，性能测试是回归测试实践中的一个潜在弱点。"}]}]},{"ID":"20250513155545-mgq5sgl","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513155545-mgq5sgl","updated":"20250513155545"},"Children":[{"ID":"20250513155545-tycxt7k","Type":"NodeParagraph","Properties":{"id":"20250513155545-tycxt7k","updated":"20250513155545"},"Children":[{"Type":"NodeText","Data":"ROI：通常，与本地化优化相比，设计级优化需要更多的投资才能实施，并且并不总是能带来更高的性能改进。但是，对于所有三种编程语言，设计级别的优化更有可能与其他方面的 return 相关联，例如可维护性和可读性等。我们暗示，设计级优化的一个激励场景是在修复性能问题的同时实现长期利益。"}]}]}]},{"ID":"20250513155921-zcf7rq5","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513155921-zcf7rq5","updated":"20250513155936"},"Children":[{"Type":"NodeText","Data":"BACKGROUND"}]},{"ID":"20250513155545-hn0zbzi","Type":"NodeParagraph","Properties":{"id":"20250513155545-hn0zbzi","updated":"20250513155545"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513155545-ouuqxis.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513155545-gen9kin","Type":"NodeList","ListData":{},"Properties":{"id":"20250513155545-gen9kin","updated":"20250513155932"},"Children":[{"ID":"20250513155545-8xmb503","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513155545-8xmb503","updated":"20250513155932"},"Children":[{"ID":"20250513155545-mnxh1yv","Type":"NodeParagraph","Properties":{"id":"20250513155545-mnxh1yv","updated":"20250513155932"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"设计结构矩阵( Design Structure Matrix, DSM )"}]}]}]},{"ID":"20250513155545-ox12to3","Type":"NodeParagraph","Properties":{"id":"20250513155545-ox12to3","updated":"20250513155545"},"Children":[{"Type":"NodeText","Data":"设计结构矩阵 （DSM） 由 Baldwin 和 Clark [23] 提出，用于捕获系统设计的复杂性。DSM 是一个方阵，其中每个设计变量都对应于矩阵的一行和一列。当且仅当与单元格行对应的设计决策取决于与该列对应的设计决策时，才会选中该单元格。DSM 将模块表示为沿对角线的块。DSM 通常用于软件系统的建模 [24]， [25]。元素可以表示源文件。每个单元格捕获行上的文件到列上的文件的不同类型的结构依赖关系。在这项工作中，我们模拟了两种一般类型的结构依赖关系：1） “Ext”，表示行上的文件扩展了列上的文件;2） “dp”，表示从行上的文件到列上的文件的其他常规类型的结构依赖关系，例如方法调用。图 1（a） 是一个 DSM 示例，其中包含 5 个源文件，这些文件与开源项目 PDFBox 中的性能问题 PDFBOX-2303（稍后详细说明）相关联。行和列表示源文件，按相同的顺序排列。单元格显示这些文件之间的依赖关系。例如，Cell[2， 1] 显示“ext”，这意味着 PDTrueTypeFont（第 2 行）扩展了 TrueTypeFont（第 1 行）。Cell[4,2] 表示 “dp”，这意味着 TTFGlyph2D（第 4 行）对 PDTrueTypeFont（第 2 行）具有结构依赖性。"}]},{"ID":"20250513155545-klyp7um","Type":"NodeList","ListData":{},"Properties":{"id":"20250513155545-klyp7um","updated":"20250513155936"},"Children":[{"ID":"20250513155545-r3hst95","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513155545-r3hst95","updated":"20250513155936"},"Children":[{"ID":"20250513155545-eonb4fa","Type":"NodeParagraph","Properties":{"id":"20250513155545-eonb4fa","updated":"20250513155936"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Diff-DSM"}]}]}]},{"ID":"20250513155545-j9ubm0l","Type":"NodeParagraph","Properties":{"id":"20250513155545-j9ubm0l","updated":"20250513155545"},"Children":[{"Type":"NodeText","Data":"在这项工作中，我们使用基于 DSM 构建的 Diff-DSM 来专门捕获软件开发中的设计结构变化。就本研究而言，Diff-DSM 具有以下独特性："}]},{"ID":"20250513155545-j74u3qn","Type":"NodeParagraph","Properties":{"id":"20250513155545-j74u3qn","updated":"20250513155545"},"Children":[{"Type":"NodeText","Data":"1） 它仅包含修订版中涉及的文件及其结构依赖关系;"}]},{"ID":"20250513155545-2n21ukm","Type":"NodeParagraph","Properties":{"id":"20250513155545-2n21ukm","updated":"20250513155545"},"Children":[{"Type":"NodeText","Data":"2） 它突出显示了修订版中添加或删除的文件;"}]},{"ID":"20250513155545-e6egr16","Type":"NodeParagraph","Properties":{"id":"20250513155545-e6egr16","updated":"20250513155545"},"Children":[{"Type":"NodeText","Data":"3） 它突出显示了所涉及源文件之间添加和删除的结构依赖关系。Diff-DSM 是通过将修订 ID 和项目存储库作为输入 [26] 来自动计算的。"}]},{"ID":"20250513155545-3aaczi0","Type":"NodeParagraph","Properties":{"id":"20250513155545-3aaczi0","updated":"20250513155545"},"Children":[{"Type":"NodeText","Data":"例如，图 1（b） 是一个 Diff-DSM，显示了修复性能问题 PDFBOX-2303 后导致的设计结构差异。此问题会导致在渲染大型外部字形（例如亚洲字形）（如“STXihei”）时速度变慢。原因是该程序必须加载和构造 37255 个字形表的对象，每个表的大小为 15.7 Mb。为了解决这个问题，开发人员创建了一个名为 GlyphTable 的新文件，它只负责在必要时加载单个字形表。图 1（b） 说明了该分辨率的整体设计结构变化。首先，顶行 GlyphTable 以绿色突出显示，表示 GlyphTable 是此修订版中添加的新文件，其中包含消除不必要数据加载的核心策略。其次，Cell[2， 1]、Cell[3， 1]、Cell[4， 1] 和 Cell [5， 1] 表示 “+dp”（绿色字体），这表示从 TrueTypeFont（第 2 行）到 TTFGlyph2D（第 5 行）的四个文件增加了对新文件 GlyphTable（第 1 行）的依赖关系，以利用优化的加载策略。此外，单元格 [4， 2] 显示“-dp”（红色字体），这意味着 GlyfCompositeDescript（第 4 行）从原始 TrueTypeFont（第 2 行）中删除了依赖项，其中包含导致冗余和不必要数据加载的原始加载方法。如本例所示，Diff-DSM 为我们提供了一个镜头，用于审查设计结构更改的基本原理以实现性能优化"}]},{"ID":"20250513155545-yxmdut4","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513155545-yxmdut4","updated":"20250513160104"},"Children":[{"Type":"NodeText","Data":"RESEARCH QUESTIONS"}]},{"ID":"20250513155545-jsijqos","Type":"NodeParagraph","Properties":{"id":"20250513155545-jsijqos","updated":"20250513160012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"RQ1：现实生活中软件性能问题的共同根源是什么?"},{"Type":"NodeText","Data":"从业者应该意识到性能问题的常见类型，才能够有效地预防、识别和修复绩效问题。我们分两部分来回答这个问题："}]},{"ID":"20250513155545-clp55kc","Type":"NodeList","ListData":{},"Properties":{"id":"20250513155545-clp55kc","updated":"20250513160018"},"Children":[{"ID":"20250513155545-d03bmue","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513155545-d03bmue","updated":"20250513160016"},"Children":[{"ID":"20250513155545-4uoe9hp","Type":"NodeParagraph","Properties":{"id":"20250513155545-4uoe9hp","updated":"20250513160016"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"RQ-1.1性能问题的常见根源是什么?"},{"Type":"NodeText","Data":"而编程语言又是如何影响这些根源的?这个子RQ的动机是评估编程语言对根本原因的影响。一方面，我们旨在揭示根本原因是否对所有三种语言都具有普遍性；另一方面，我们也有兴趣看看某些根源在特定的语言中是否更相关。相关观察可以为使用不同语言的从业者提供经验性见解。"}]}]},{"ID":"20250513155545-95ljfl4","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513155545-95ljfl4","updated":"20250513160018"},"Children":[{"ID":"20250513155545-ecnd089","Type":"NodeParagraph","Properties":{"id":"20250513155545-ecnd089","updated":"20250513160018"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"RQ-1.2是否可用工具解决每个根本原因的情况?"},{"Type":"NodeText","Data":"我们的目标是从现有文献中找到可用来检测和修复使用不同编程语言实现的实际项目中的性能问题的工具。"}]}]}]},{"ID":"20250513155545-ycfaamy","Type":"NodeParagraph","Properties":{"id":"20250513155545-ycfaamy","updated":"20250513160028"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"RQ2：性能问题是否通过设计层面的优化来解决。"},{"Type":"NodeText","Data":"如果是，如何解决?我们假设一些性能问题需要设计级的优化，以最大限度地提高性能，同时保证代码质量。我们也分两部分讨论这个RQ："}]},{"ID":"20250513155545-gd299o8","Type":"NodeList","ListData":{},"Properties":{"id":"20250513155545-gd299o8","updated":"20250513160040"},"Children":[{"ID":"20250513155545-12ijvxw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513155545-12ijvxw","updated":"20250513160032"},"Children":[{"ID":"20250513155545-9jca526","Type":"NodeParagraph","Properties":{"id":"20250513155545-9jca526","updated":"20250513160032"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"RQ-2.1 需要设计级优化的性能问题占多少百分比？"},{"Type":"NodeText","Data":"以及，典型的设计级优化模式是什么？我们根据修复性能问题的更改范围来区分局部和设计级别的优化解决方案。对于设计级分辨率，我们进一步研究了典型的设计级优化模式是什么，以及为什么它们在解决某些性能问题时是必需的。"}]}]},{"ID":"20250513155545-9raneve","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513155545-9raneve","updated":"20250513160036"},"Children":[{"ID":"20250513155545-p0yfuia","Type":"NodeParagraph","Properties":{"id":"20250513155545-p0yfuia","updated":"20250513160036"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"RQ-2.2 编程语言会影响 designlevel 优化模式吗？"},{"Type":"NodeText","Data":"我们研究了编程语言是否以及如何影响 designlevel 优化模式及其分布。"}]}]},{"ID":"20250513155545-eurxx7n","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513155545-eurxx7n","updated":"20250513160040"},"Children":[{"ID":"20250513155545-k6ftly5","Type":"NodeParagraph","Properties":{"id":"20250513155545-k6ftly5","updated":"20250513160040"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"RQ-2.3 根本原因或项目领域是否会影响设计级优化模式？"},{"Type":"NodeText","Data":"我们研究了设计级优化在其他两个维度上的分布，包括根本原因和项目域。目标是揭示这些因素是否会影响设计级优化模式的选择。"}]}]}]},{"ID":"20250513155545-9bye6yi","Type":"NodeParagraph","Properties":{"id":"20250513155545-9bye6yi","updated":"20250513160045"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"RQ3：测试代码是否随着性能优化而改变。"},{"Type":"NodeText","Data":"如果是，如何改变?软件测试是现代软件开发中不可或缺的一部分。软件性能问题通常通过执行测试用例来发现\"热点\" [ 27 ]，[ 28 ]，[ 29 ]。该RQ研究了测试代码随性能优化而变化的可能性，同时也揭示了测试代码与生产代码在性能优化中共同变化的本质。我们分两部分讨论这个RQ："}]},{"ID":"20250513155545-hue85o6","Type":"NodeList","ListData":{},"Properties":{"id":"20250513155545-hue85o6","updated":"20250513160052"},"Children":[{"ID":"20250513155545-nk6a1gv","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513155545-nk6a1gv","updated":"20250513160049"},"Children":[{"ID":"20250513155545-isy65t2","Type":"NodeParagraph","Properties":{"id":"20250513155545-isy65t2","updated":"20250513160049"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"RQ-3.1从业者在性能优化中更改测试代码的频率?"},{"Type":"NodeText","Data":"我们假设，由于变更的范围和复杂程度更大，相比本地化优化，设计级优化更可能涉及测试代码的修改。"}]}]},{"ID":"20250513155545-ylynzrg","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513155545-ylynzrg","updated":"20250513160052"},"Children":[{"ID":"20250513155545-edevxk5","Type":"NodeParagraph","Properties":{"id":"20250513155545-edevxk5","updated":"20250513160052"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"RQ-3.2性能优化中常见的测试-生产共变模式有哪些?"},{"Type":"NodeText","Data":"我们揭示了性能优化的生产代码的修改是否以及如何引起测试代码的变化。我们对测试-生产合作进行了分类"}]}]}]},{"ID":"20250513155545-jlbmsoy","Type":"NodeParagraph","Properties":{"id":"20250513155545-jlbmsoy","updated":"20250513160057"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"RQ4：用于修复性能问题的ROI (投资回报率)是什么?"},{"Type":"NodeText","Data":"软件开发受限于有限的资源和时间，关注的是性能以外的质量属性。这种RQ有助于实践者经济地对待绩效问题。我们把这个RQ分成两部分来讨论，具体如下："}]},{"ID":"20250513155545-ynlywfc","Type":"NodeList","ListData":{},"Properties":{"id":"20250513155545-ynlywfc","updated":"20250513160104"},"Children":[{"ID":"20250513155545-x3ayrcb","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513155545-x3ayrcb","updated":"20250513160100"},"Children":[{"ID":"20250513155545-quu6fzr","Type":"NodeParagraph","Properties":{"id":"20250513155545-quu6fzr","updated":"20250513160100"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"RQ-4.1解决性能问题的总体投资回报率是多少?"},{"Type":"NodeText","Data":"特别是，开发人员是否关心性能优化的其他方面的好处?我们衡量参与开发者的数量和讨论的次数作为投资的代理，衡量绩效改善的程度作为回报。此外，我们还调查了开发人员在解决性能问题时是否还关注其他方面的好处，例如可维护性和可读性。"}]}]},{"ID":"20250513155545-4rqsgox","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513155545-4rqsgox","updated":"20250513160104"},"Children":[{"ID":"20250513155545-fekx155","Type":"NodeParagraph","Properties":{"id":"20250513155545-fekx155","updated":"20250513160104"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"RQ-4.2本地化和设计级优化的投资回报率如何比较?"},{"Type":"NodeText","Data":"重点比较本地化和设计级优化的投资回报率。这为实践者对两种优化策略进行优先排序提供了思路。特别地，我们假设，当开发人员还关心其他方面的好处（如可维护性）作为回报时，他们倾向于进行设计级优化。"}]}]}]},{"ID":"20250513155545-s4gkmpp","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513155545-s4gkmpp","updated":"20250513160149"},"Children":[{"Type":"NodeText","Data":"STUDY SUBJECTS AND APPROACH"}]},{"ID":"20250513155545-23b7wwt","Type":"NodeList","ListData":{},"Properties":{"id":"20250513155545-23b7wwt","updated":"20250513160116"},"Children":[{"ID":"20250513155545-s6qcvw0","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513155545-s6qcvw0","updated":"20250513160116"},"Children":[{"ID":"20250513155545-p4v49dc","Type":"NodeParagraph","Properties":{"id":"20250513155545-p4v49dc","updated":"20250513160116"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Study subject"}]}]}]},{"ID":"20250513155545-vhryftp","Type":"NodeParagraph","Properties":{"id":"20250513155545-vhryftp","updated":"20250513155545"},"Children":[{"Type":"NodeText","Data":"本研究重点关注来自 Apache Software Foundation 的 13 个开源项目的 570 个性能问题 [43]（如表 1）。这些实验对象是根据以下考虑因素选择的。首先，这些项目使用三种非常常用的编程语言实现，包括 Java（第 1 行到第 5 行）、Python（第 6 行到第 10 +行）和 C++（第 11 行到第 13 行）。特别值得注意的是，如“代码库中的焦点 LAN +（%）”列所示，对于大多数项目，我们研究主要编程语言，它占代码库的 90% 以上。Avro、Beam 和 PyLucene 是例外，thelanguagewefocus on 分别占用了其代码库的 44% （Java）、18% （Python） 和 39% （Python）。在分析每个问题时，我们会在问题解决中确认编程语言。因此，我们是否关注项目的主要语言并不影响我们研究结果的有效性。总体而言，我们的研究包括来自 Java 项目的 192 个性能问题、来自 Python 项目的 162 个性能问题和 C++ 项目的 216 个性能问题。这有助于我们调查语言对实际性能问题的原因和解决方法的影响。其次，项目位于不同的域中，如 “Description” 列所示。因此，这些项目的性能问题代表了各个领域的不同特征。数据多样性有助于我们对不同性质的现实性能问题进行一般观察。第三，这些项目都被广泛接受、成功，并且仍然活跃在开源社区中。最后，这些主题的源代码、版本控制存储库和问题跟踪系统都组织得很好，并且在 Apache 软件基金会 [43] 上很容易获得。 它们为我们的研究提供了高质量的性能问题数据。"}]},{"ID":"20250513155545-bg8d7zc","Type":"NodeParagraph","Properties":{"id":"20250513155545-bg8d7zc","updated":"20250513155545"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513155545-pv0xskn.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513155545-74210jn","Type":"NodeList","ListData":{},"Properties":{"id":"20250513155545-74210jn","updated":"20250513160123"},"Children":[{"ID":"20250513155545-0s5a3fe","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513155545-0s5a3fe","updated":"20250513160123"},"Children":[{"ID":"20250513155545-y6w99gc","Type":"NodeParagraph","Properties":{"id":"20250513155545-y6w99gc","updated":"20250513160123"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Study Approach"}]}]}]},{"ID":"20250513155545-w2jwlgo","Type":"NodeParagraph","Properties":{"id":"20250513155545-w2jwlgo","updated":"20250513160133"},"Children":[{"Type":"NodeText","Data":"第 1 步：数据收集。我们从所选项目的缺陷跟踪系统中收集性能问题。"}]},{"ID":"20250513155545-01a8ma5","Type":"NodeParagraph","Properties":{"id":"20250513155545-01a8ma5","updated":"20250513160135"},"Children":[{"Type":"NodeText","Data":"第 2 步：根本原因分析。我们通过检查问题报告和代码修订来对检索到的性能问题进行根本原因分析，然后从文献中识别出解决相关问题的可用工具（RQ1）。"}]},{"ID":"20250513155545-izebxjl","Type":"NodeParagraph","Properties":{"id":"20250513155545-izebxjl","updated":"20250513155545"},"Children":[{"Type":"NodeText","Data":"第 3 步：设计级别优化分析。我们专注于分析需要设计级别优化的性能问题（RQ2）。"}]},{"ID":"20250513155545-ljb385d","Type":"NodeParagraph","Properties":{"id":"20250513155545-ljb385d","updated":"20250513160144"},"Children":[{"Type":"NodeText","Data":"第 4 步：测试/生产代码协同变更分析。我们分析涉及性能优化的测试代码修订（RQ3）。"}]},{"ID":"20250513155545-3497lah","Type":"NodeParagraph","Properties":{"id":"20250513155545-3497lah","updated":"20250513155545"},"Children":[{"Type":"NodeText","Data":"第 5 步：投资回报分析。我们检查性能问题的投资回报（RQ4）。"}]},{"ID":"20250513155545-uinnyj4","Type":"NodeParagraph","Properties":{"id":"20250513155545-uinnyj4","updated":"20250513155545"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513155545-wu3as7a.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513155545-c52pv67","Type":"NodeList","ListData":{},"Properties":{"id":"20250513155545-c52pv67","updated":"20250513160149"},"Children":[{"ID":"20250513155545-vzin8sz","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513155545-vzin8sz","updated":"20250513160149"},"Children":[{"ID":"20250513155545-1hfqtc5","Type":"NodeParagraph","Properties":{"id":"20250513155545-1hfqtc5","updated":"20250513160149"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"数据收集"}]}]}]},{"ID":"20250513155545-qi1bkd5","Type":"NodeParagraph","Properties":{"id":"20250513155545-qi1bkd5","updated":"20250513155545"},"Children":[{"Type":"NodeText","Data":"如表 1 所示，我们最初从 13 个项目的跟踪系统中收集了总共 166,747 个问题。这些问题追溯到每个项目的创建。首先，我们应用关键词匹配来选择与性能相关的问题，类似于先前研究中的做法[6]，[44]，[45]。使用的关键词包括：“快，慢，执行，延迟，吞吐量，优化，速度，启发式，浪费，高效，不必要的，冗余，太多次数，很多时间，太多时间”。这些是先前研究中使用关键词的组合。如果一个问题的摘要或描述包含一个或多个关键词，则它可能是性能问题。如表 1 第四列所示，通过匹配相关关键词，共保留了 1,225 个问题。接下来，我们手动阅读和验证每个问题报告，以排除误报。例如，“性能”有时指的是开发者的生产力。这进一步提炼出表 1“已验证”列中显示的 868 个问题。 我们识别并收集每个性能问题的代码修订版本，来源包括：1）如果可用，来自 Apache JIRA 问题报告中的建议补丁；或 2）通过在提交消息中定位出现的 issue ID，从项目代码仓库，如 Github。没有链接解决方案的问题，要么因为未解决，要么因为链接缺失，将被删除。我们最终确定了 570 个已解决性能问题用于本研究。这些问题通过其 ID（即表 2 中的 D1）进行引用。在准备以下步骤时，我们手动标注了每个问题报告中四个关键信息方面的内容（如果可用）。它们是：1）描述根本原因的文本（D2），2）建议的解决方案，3）性能分析数据（D12），以及 4）任何其他关注方面（D15），例如可维护性、可读性等。图 3 是一个标注问题报告的示例，PDFBOX-591 [46]。"}]},{"ID":"20250513155545-mox1vph","Type":"NodeParagraph","Properties":{"id":"20250513155545-mox1vph","updated":"20250513155545"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513155545-gqeq4d7.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513155545-yr9yc1q","Type":"NodeParagraph","Properties":{"id":"20250513155545-yr9yc1q","updated":"20250513155545"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513155545-f5g0v8u.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]}]}