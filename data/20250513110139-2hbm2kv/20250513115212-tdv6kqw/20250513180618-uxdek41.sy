{"ID":"20250513180618-uxdek41","Spec":"1","Type":"NodeDocument","Properties":{"id":"20250513180618-uxdek41","title":"2017-ICSE-NIER-Performance Metamorphic Testing: Motivation and Challenges","type":"doc","updated":"20250513180636"},"Children":[{"ID":"20250513180623-kg7phgn","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513180623-kg7phgn","updated":"20250513180628"},"Children":[{"Type":"NodeText","Data":"摘要"}]},{"ID":"20250513180623-iwtqafb","Type":"NodeParagraph","Properties":{"id":"20250513180623-iwtqafb","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"性能测试是一项具有挑战性的任务，主要是因为缺乏测试预言机，即决定程序在特定工作负载下的性能是否可接受或由于性能错误而较差的机制。蜕变测试可以通过利用被测程序多次执行的输入和输出之间的关系（所谓的蜕变关系），在没有预言机的情况下生成测试用例。在过去的二十年中，蜕变测试已成功用于检测从 Web 服务到模拟器等各种领域的功能故障。然而，蜕变测试在检测性能缺陷方面的适用性仍然是一个尚未探索的话题。在这篇愿景论文中，我们引入了性能蜕变关系（PMR）作为被测程序多次执行的性能测量之间的预期关系。我们假设这些关系可以转化为自动检测性能错误的断言，从而无需复杂的基准测试和领域专家指导。另一个好处是，PMR 可以转化为适应度函数，以指导基于搜索的技术生成违反关系的测试数据，从而揭示错误。这个新颖的想法是通过示例和对这个充满希望的主题中的一些挑战的概述来激发的。"}]},{"ID":"20250513180623-0vckng1","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513180623-0vckng1","updated":"20250513180630"},"Children":[{"Type":"NodeText","Data":"Introduction"}]},{"ID":"20250513180623-hk3jlde","Type":"NodeParagraph","Properties":{"id":"20250513180623-hk3jlde","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"性能测试旨在揭示导致被测系统显着性能下降的编程错误[1]，例如内存消耗过多。性能缺陷在已发布的软件程序中非常常见。例如，Mozilla 开发人员每月修复用户报告的 5 到 60 个性能错误[2]。同样，移动应用程序的新兴趋势给性能测试带来了新的挑战，例如检测臭名昭著的能量泄漏或内存膨胀[3]、[4]。总体而言，性能错误会导致可用性差和资源浪费，这可能会导致用户流失或价值数亿美元的软件项目被放弃[1]，[2]。"}]},{"ID":"20250513180623-t64z16s","Type":"NodeParagraph","Properties":{"id":"20250513180623-t64z16s","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"与功能错误相比，性能错误不会在被测程序中产生错误结果或崩溃，因此不能通过简单地检查程序输出来检测它们。例如，假设浏览器需要200 毫秒来呈现给定的网页：这是预期的性能吗？多慢应该被视为性能错误？回答这些问题不仅需要充分了解应用程序，还需要考虑计算机硬件或其当前工作负载等其他方面。与功能故障相比，性能错误更难检测，并且需要更多的时间和精力来修复 [1]。这部分是由于缺乏测试预言机，即决定程序在一定工作负载下的性能是否可接受的机制，即预言机问题。性能测试中的典型预言是人类的判断，通常涉及开发人员之间的长时间讨论，或具有相似功能的不同程序（或同一程序的不同版本）之间的比较[1]-[3]。 缺乏自动化预言机被认为是性能测试的关键挑战之一。金等人[2] 对109 个现实世界的性能错误进行了实证研究，得出的结论是“需要能够智能比较输入之间的性能数据并自动发现性能问题是否存在的技术”。刘等人[3]研究了Android应用程序中的70个现实世界的性能错误，并得出了相同的结论：“有效的性能测试需要自动化的预言机来判断性能下降”。同样，尼斯托尔等人。 [1] 分析了来自三个成熟开源项目的 210 个性能错误，并得出结论：“需要更好的预言机来发现性能错误”。当测试执行的预期输出未知时，蜕变测试通过提供替代方案来缓解预言机问题 [5]。蜕变测试不是检查单个程序执行的输出，而是检查被测程序的多次执行是否满足某些称为蜕变关系的必要属性。例如，考虑程序 merge(L1,L2)，它将两个列表合并为一个有序列表。参数的顺序不应影响结果，可以表示为以下蜕变关系：merge(L1,L2)=merge(L2,L1)。蜕变关系由所谓的源测试用例（L1，L2）和从源测试用例派生的一个或多个后续测试用例（L2，L1）组成。可以通过使用特定输入值将蜕变关系实例化为一个或多个蜕变测试，例如 merge([2, 3], [1, 5]) = merge([1, 5], [2, 3])。 如果源测试用例及其后续测试用例的输出违反了蜕变关系，则称蜕变测试失败，表明被测程序包含错误。在最近的一项调查中，Segura 等人。 [6] 回顾了大约120 篇关于蜕变测试的论文，并确定了该技术在从 Web 服务到编译器等各个领域的成功应用。有趣的是，我们发现所有评论的论文都集中在使用蜕变测试来检测功能故障。因此，蜕变测试在检测性能缺陷方面的潜在应用仍有待探索。在本文中，我们提出以下假设："}]},{"ID":"20250513180623-it84owf","Type":"NodeParagraph","Properties":{"id":"20250513180623-it84owf","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"蜕变测试是解决性能测试中的预言机问题的有用技术，支持性能错误的自动检测。"}]},{"ID":"20250513180623-k7kbv9e","Type":"NodeParagraph","Properties":{"id":"20250513180623-k7kbv9e","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"直观的想法如下。让我们假设调用 merge(l1,l2) 需要300ms 来提供输出，其中 l1 和 l2 是两个特定列表：这是正确的吗？很难说。直观上，如果向两个列表添加更多元素，则合并列表所需的执行时间应该相等或更长。这可以表示为以下性能蜕变关系 (PMR)：T (merge(L1,L2)) ≤ T (merge(L1 ∪ L3,L2 ∪ L4))，其中L3 和L4 是两个列表，每个列表包含 k 个随机项，其中 k\u003e0。基于此，可以构造如下变质测试：T(merge(l1,l2))≤T(merge(l1∪l3,l2∪l4))，其中l3和l4是两个列表，每个列表有1000个随机数。PMR 的一个主要好处是它们独立于所选的输入，即任何 L1−4 都应该满足该关系。另外，如果源测试用例和后续测试用例在同一台计算机上执行并且紧接着另一台计算机执行，则它们应该同等地受到外部因素（例如硬件设置或计算机工作负载）的影响，并且该关系仍然成立（注仍应处理缓存预热等问题）。因此，PMR 可以转化为自动检测性能错误的断言，从而无需复杂的基准测试和人工判断。作为该提案的另一个好处，PMR 可以转化为适应度函数，以指导基于搜索的技术生成违反关系的测试数据。例如，之前的 PMR 可以转换为以下适应度函数（最大化）：(T (merge(L1,L2)) − T (merge(L1 ∪L3,L2 ∪ L4)))。直观上，该函数可用于搜索源测试用例的执行时间大于后续测试用例的执行时间的输入。 换句话说，可以将搜索引导到尽可能违反关系的输入。在实践中，这意味着该方法不仅可以缓解性能测试中的预言机问题，而且还可以使用智能技术来自动检测性能错误。接下来，我们首先在第二节中介绍一些受现实世界性能错误启发的激励示例。第三节介绍了与 PMR 定义相关的一些挑战。假阳性和假阴性的管理也提出了分别在第四节和第五节中描述的悬而未决的问题。第六节讨论了测试数据生成的问题以及如何将 PMR 转化为适应度函数来指导基于搜索的测试技术。最后，第七节总结了我们的主要结论。"}]},{"ID":"20250513180623-96b2hz1","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513180623-96b2hz1","updated":"20250513180636"},"Children":[{"Type":"NodeText","Data":"MOTIVATING EXAMPLES"}]},{"ID":"20250513180623-o73d6rt","Type":"NodeParagraph","Properties":{"id":"20250513180623-o73d6rt","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"在本节中，我们将介绍几个受实际性能错误启发的 PMR。为了便于理解，每种关系都故意以简单朴素的方式呈现，其中一些关系将在下一节中进行更深入的研究。"}]},{"ID":"20250513180623-s856n22","Type":"NodeParagraph","Properties":{"id":"20250513180623-s856n22","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"BookmarkAll：用户报告称，Firefox 在打开大量标签页的情况下单击“全部书签（标签页）”时花费的时间过长1 [2]。该问题是由于使用单独的数据库事务为每个选项卡添加书签而引起的，随着选项卡数量的增加，性能逐渐降低。通过将所有任务批处理到单个事务中修复了该错误。受此错误的启发，可以定义以下 PMR："}]},{"ID":"20250513180623-7nnqxbp","Type":"NodeParagraph","Properties":{"id":"20250513180623-7nnqxbp","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"T (bookmarkAll(x)) ≤ T (bookmarkAll(y))"}]},{"ID":"20250513180623-x5wfpii","Type":"NodeParagraph","Properties":{"id":"20250513180623-x5wfpii","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"其中 x 和 y 是正整数，表示要添加书签的选项卡数量，并且 x\u003cy。直观上，该关系表示操作的执行时间预计会随着要添加书签的打开选项卡的数量而增加。"}]},{"ID":"20250513180623-ztaeh3f","Type":"NodeParagraph","Properties":{"id":"20250513180623-ztaeh3f","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"LoadImg：一些 Chrome 用户报告在操作图像时出现内存泄漏，这被归类为bug2。加载不同大小的图像时，此错误会导致意外的内存使用量。渲染大图像预计会比渲染小图像消耗更多内存。但是，如果在大图像之后加载小图像，则内存使用量会增加。这是由于垃圾收集器出现问题，它在应该工作的时候却没有工作。受此错误的启发，可以定义以下 PMR："}]},{"ID":"20250513180623-8pudjlp","Type":"NodeParagraph","Properties":{"id":"20250513180623-8pudjlp","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"M (loadImg(img1)) ≥ M (loadImg(img2))"}]},{"ID":"20250513180623-htchq0q","Type":"NodeParagraph","Properties":{"id":"20250513180623-htchq0q","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"其中 img2 是从 img1 派生的图像，但尺寸较小，例如裁剪或降低其质量。这种关系表示加载特定大小的图像应该比加载较小的图像消耗更多的内存，或者消耗相同的内存。"}]},{"ID":"20250513180623-r1a3k6w","Type":"NodeParagraph","Properties":{"id":"20250513180623-r1a3k6w","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"UpdateGUI。 Zmanim 是一款位置感知应用程序，用于提醒犹太人白天的祈祷时间。该应用程序根据用户的位置和相应的时区发送警报。用户注意到代码中的缺陷导致电池电量过度消耗（即能量泄漏）[3]。在某些情况下，即使应用程序切换到后台，应用程序也会不断接收位置更改以更新其 GUI，从而浪费宝贵的电池电量。受此性能错误的启发，可以定义以下 PMR："}]},{"ID":"20250513180623-540mbbk","Type":"NodeParagraph","Properties":{"id":"20250513180623-540mbbk","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"E(updateGU I(t,‘active’)) "},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003e"}]},{"Type":"NodeText","Data":"E(updateGU I(t,‘paused’))"}]},{"ID":"20250513180623-ql2atx5","Type":"NodeParagraph","Properties":{"id":"20250513180623-ql2atx5","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"其中 t 是某个使用测试模式（例如，用户操作序列），第二个输入值指示应用程序的最终状态，“活动”或“暂停”。直观上，该关系表明移动应用程序在活动时应该比在暂停时消耗更多的能量。"}]},{"ID":"20250513180623-9attfd4","Type":"NodeParagraph","Properties":{"id":"20250513180623-9attfd4","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"DEFINING PERFORMANCE METAMORPHIC RELATIONS"}]},{"ID":"20250513180623-qsv5yp3","Type":"NodeParagraph","Properties":{"id":"20250513180623-qsv5yp3","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"蜕变测试背后的基本原理是，当观察具有不同输入值的两个或多个程序执行之间的差异时，可能会出现错误，例如 merge(L1,L2)=merge(L2,L1)。然而，目前尚不清楚某些输入值会在多大程度上暴露性能错误，而其他输入值则无法检测到性能错误。为了探讨这个问题，我们回顾了一些有关性能测试的最新文献。金等人发现三分之二的性能错误需要具有特殊功能的输入才能显现出来[2]。例如，要触发Firefox 中的错误，用户必须在许多打开的选项卡上单击“全部添加书签”。类似地，刘等人[3] 发现三分之一的错误需要特殊的用户交互才能被发现。例如，Zmanim 的能量泄漏需要执行以下步骤才能重现[3]：(1)打开GPS，(2)配置Zmanim 使用当前位置，(3) 启动其主要活动，以及 (4) 点击“ GPS 获取位置时的“主页”按钮。这些发现表明，当仅使用某些输入来执行程序时，会发现很大一部分性能错误，这意味着在比较源测试用例和后续测试用例的行为时可能会表现出一些缺陷。有趣的是，这与Jin等人的结论是一致的。 [2]，他写道：“如果软件测试仅执行每个有缺陷的代码单元一次，则无法有效地暴露这些错误[性能错误]，不幸的是，这是大多数功能测试的目标”。然而，其他一些结果表明性能蜕变测试的适用性可能是有限的。金等人[2] 报告称，一部分 bug（他们研究的 109 个中的 15 个）始终处于活动状态，因为它们位于所有输入执行的代码中，例如、启动或关闭阶段。实际上，这意味着 PMR 很少能够检测到这种类型的性能错误，因为该错误会同等影响源测试用例和后续测试用例。例如，假设Firefox 启动阶段出现故障，导致数据库事务处理时间比预期长十倍。该错误将同样影响 PMR1 中的源测试用例和后续测试用例，因此任何输入都会满足该关系，而不会检测到该错误。这会带来以下挑战："}]},{"ID":"20250513180623-8a88qx6","Type":"NodeParagraph","Properties":{"id":"20250513180623-8a88qx6","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"挑战 1：识别不同应用场景中的PMR（最好是在实际设置中），并展示其在检测性能缺陷方面的有效性。"}]},{"ID":"20250513180623-2uu166c","Type":"NodeParagraph","Properties":{"id":"20250513180623-2uu166c","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"挑战 2：制定PMR 定义指南。这些可能是依赖于领域的，并希望得到对每个领域报告的典型性能错误特征的研究的支持。"}]},{"ID":"20250513180623-22dtqm7","Type":"NodeParagraph","Properties":{"id":"20250513180623-22dtqm7","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"MANAGING FALSE POSITIVES"}]},{"ID":"20250513180623-z5vy8qa","Type":"NodeParagraph","Properties":{"id":"20250513180623-z5vy8qa","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"在功能蜕变测试中，大多数蜕变关系是为确定性程序定义的，其中对于某些输入，关系要么满足，要么违反，例如 merge([2, 3], [1, 5]) = merge([1, 5 ], [2, 3])。相比之下，非功能属性（例如执行时间、内存消耗或能源使用）的测量本质上是不确定的。例如，由于设备工作负载、通信问题或自动更新，移动应用程序消耗的电池电量在每次执行时可能会有所不同。在实践中，这意味着有时可能会违反 PMR，而这并不是性能错误的指标，从而导致误报。一些方法已经解决了使用蜕变测试来测试非确定性程序的问题。 Guderlei 和 Mayer [7] 提出了统计蜕变测试。该方法的工作原理是通过执行源测试用例和后续测试用例来生成两个或多个输出序列。然后，使用统计假设检验根据输出序列的统计特性对输出序列进行比较。墨菲等人[8] 认为，在某些情况下，输出的轻微变化实际上并不表示存在错误，例如浮点计算。为了解决这个问题，作者提出了启发式测试预言机的概念，通过定义一个函数来确定输出是否“足够接近”以被认为是相等的。受这些方法的启发，我们设想至少有两种补充方法来管理由性能蜕变测试的不确定性引起的误报，即："}]},{"ID":"20250513180623-9kwgat2","Type":"NodeParagraph","Properties":{"id":"20250513180623-9kwgat2","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"1）违规阈值：该方法包括多次运行每个变质测试并在数量中设置阈值我们认为可以接受的违规行为。 例如，假设我们运行蜕变测试 100 次，违规阈值为 5%。如果违反次数大于 5，则违反 PMR，否则满足。"}]},{"ID":"20250513180623-qjmelie","Type":"NodeParagraph","Properties":{"id":"20250513180623-qjmelie","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"2）关系阈值：这种方法受到[8]的启发，包括设置阈值以允许源测试用例和后续测试用例的性能测量存在一定的差异。 PMR'1 描述了使用这种方法的 PMR1 的改进版本，其中 β 代表比较的阈值。 β 的值可以设置为绝对值（例如 100ms）或相对于源和后续测试用例的相对时间值，例如 y × T (bookmarkAll(x))/x。例如，假设我们运行 x = 5 的源测试用例，观察到执行时间为 250 毫秒。接下来，运行后续测试用例，y = 7，执行时间为 210ms。这个微小的差异（40 毫秒）可能并不表示存在错误，因为外部因素可能会影响执行时间。然而，它违反了 PMR1，产生误报。然而，设置 β = 350ms，将满足关系 PMR′1，因为观察到的差异不显着而不能被视为失败，即 250 − 210 ≤ 350。T (bookmarkAll(x)) − T (bookmarkAll(y)) ≤ β (PMR′1)"}]},{"ID":"20250513180623-tceyml9","Type":"NodeParagraph","Properties":{"id":"20250513180623-tceyml9","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"所有这些都可以总结为以下挑战："}]},{"ID":"20250513180623-evkd2yf","Type":"NodeParagraph","Properties":{"id":"20250513180623-evkd2yf","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"挑战 3：评估使用违规和关系阈值以避免误报的可行性，并为有效阈值的定义提供指导。"}]},{"ID":"20250513180623-mhako6k","Type":"NodeParagraph","Properties":{"id":"20250513180623-mhako6k","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"挑战 4：提出新方法来解决 PMR 定义中的误报问题。"}]},{"ID":"20250513180623-e4bctbr","Type":"NodeParagraph","Properties":{"id":"20250513180623-e4bctbr","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"MANAGING FALSE NEGATIVES"}]},{"ID":"20250513180623-glzjdjd","Type":"NodeParagraph","Properties":{"id":"20250513180623-glzjdjd","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"与非确定性产生的误报类似，PMR 也可能产生误报，即尽管程序有错误但关系仍得到满足的情况。以 BookmarkAll 错误为例。根据错误报告，浏览器执行任务所需的时间随着要添加书签的选项卡数量急剧增加。这可能会导致以下情况：假设 Firefox 为 5 个选项卡添加书签需要250 毫秒，为 20 个选项卡添加书签需要 15000 毫秒。尽管执行时间差异很大 (250 ≤15000)，但仍会满足关系 T (bookmarkAll(5)) ≤ T (bookmarkAll(20))，但仍不会检测到故障。正如上一节中关于误报的说明，解决误报的明智方法还可以是使用阈值。 PMR'' 1 描述了该关系的新版本，其中 α 表示比较的阈值。同样，α的值可以设置为相对于源和后续测试用例的绝对或相对时间值，例如 (x − y) × 500。继续前面的示例，设置 α = -7500且 β = 350，则违反关系 (−7500 ≤ (250 −15000) ≤ 350)，表明存在性能错误。 α ≤ T (bookmarkAll(x)) −T (bookmarkAll(y)) ≤ β (PMR′′ 1)"}]},{"ID":"20250513180623-wxmlddg","Type":"NodeParagraph","Properties":{"id":"20250513180623-wxmlddg","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"由此，确定了以下挑战："}]},{"ID":"20250513180623-rdl51pr","Type":"NodeParagraph","Properties":{"id":"20250513180623-rdl51pr","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"挑战5：评估使用阈值识别假阴性的可行性，并为有效阈值的定义提供指导。"}]},{"ID":"20250513180623-vuxqv7a","Type":"NodeParagraph","Properties":{"id":"20250513180623-vuxqv7a","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"挑战6：提出新方法来解决PMR 定义中的误报问题。"}]},{"ID":"20250513180623-m6xln9b","Type":"NodeParagraph","Properties":{"id":"20250513180623-m6xln9b","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"TEST DATA GENERATION"}]},{"ID":"20250513180623-k6nc8km","Type":"NodeParagraph","Properties":{"id":"20250513180623-k6nc8km","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"通过测试检测性能错误需要找到能够体现被测程序中意外性能行为的测试输入。这可能极具挑战性 [1]–[4]。例如，考虑触发 Zmanim 能量泄漏所需的特定用户交互顺序，如第III 节中所述。尽管这项工作没有解决性能测试中测试数据生成的问题，但我们预计 PMR 可以帮助搜索有效的测试输入。这是因为与结果为布尔值（满足或违反）的功能蜕变关系不同，PMR 可以转换为反映关系满足或违反的程度的数字结果。实际上，这意味着 PMR 可以转化为适应度函数，用于基于搜索的测试技术。例如，PMR2可以变成以下适应度函数（要最小化）： M (loadImg(img1)) −M (loadImg(img2)) 在实践中，该适应度函数将有利于那些源消耗内存的图像测试用例消耗的内存小于后续测试用例消耗的内存。换句话说，该函数将最大程度地引导搜索违反 PMR 的输入图像，从而揭示潜在的缺陷。这导致了以下挑战："}]},{"ID":"20250513180623-ok2hq7w","Type":"NodeParagraph","Properties":{"id":"20250513180623-ok2hq7w","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"挑战7：提出并评估基于搜索的方法，用于自动生成性能蜕变测试的测试数据。"}]},{"ID":"20250513180623-3l8t3or","Type":"NodeParagraph","Properties":{"id":"20250513180623-3l8t3or","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"CONCLUSIONS"}]},{"ID":"20250513180623-5fnxxfl","Type":"NodeParagraph","Properties":{"id":"20250513180623-5fnxxfl","updated":"20250513180623"},"Children":[{"Type":"NodeText","Data":"性能错误的自动检测被认为是一个相关且具有挑战性的问题。为了解决这个问题，这篇愿景论文为一个迄今为止尚未探索的有前景的研究主题——性能蜕变测试——开辟了道路。我们概述了它如何有效地揭示用户在众所周知的实际应用程序中报告的性能错误，并列举了性能变质测试成功应用所需解决的一些挑战。"}]}]}