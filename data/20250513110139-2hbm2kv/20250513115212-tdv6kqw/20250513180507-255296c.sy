{"ID":"20250513180507-255296c","Spec":"1","Type":"NodeDocument","Properties":{"id":"20250513180507-255296c","title":"2017-Communications of the ACM-DeepXplore: Automated Whitebox Testing of Deep Learning Systems","type":"doc","updated":"20250513180551"},"Children":[{"ID":"20250513180516-9v6594y","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513180516-9v6594y","updated":"20250513180524"},"Children":[{"Type":"NodeText","Data":"摘要"}]},{"ID":"20250513180516-jk53t6x","Type":"NodeParagraph","Properties":{"id":"20250513180516-jk53t6x","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"深度学习( Deep Learning，DL )系统越来越多地部署在安全和安全关键领域，包括自动驾驶汽车和恶意软件检测，其中系统行为的正确性和可预测性对于角落案例输入至关重要。现有的DL测试严重依赖于人工标注的数据，因此往往无法针对稀有输入暴露错误行为。我们设计、实现并评估了第一个用于系统测试现实DL系统的白盒框架DeepXplore。首先，我们引入神经元覆盖率来系统地度量一个DL系统中由测试输入执行的部分。接下来，我们利用多个功能类似于交叉引用oracle的DL系统来避免人工检查。最后，我们展示了如何为DL系统寻找既能触发许多差分行为又能实现高神经元覆盖率的输入，可以表示为一个联合优化问题，并使用基于梯度的搜索技术高效地求解。"}]},{"ID":"20250513180516-w15n2yl","Type":"NodeParagraph","Properties":{"id":"20250513180516-w15n2yl","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"DeepXplore在包括ImageNet和优达学城自动驾驶挑战数据在内的5个流行数据集上训练了数以千计的神经元，在最先进的DL模型中有效地发现了数以千计的不正确的角案例行为(例如,自动驾驶汽车撞上护栏和伪装成良性软件的恶意软件)。对于所有测试的DL模型，平均而言，DeepXplore只在一台商用笔记本电脑上运行时，在1秒内生成一个测试输入，显示不正确的行为。我们进一步表明，DeepXplore生成的测试输入也可以用来重新训练相应的DL模型，使模型的精度最高提高3 %。"}]},{"ID":"20250513180516-yab3fif","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513180516-yab3fif","updated":"20250513180538"},"Children":[{"Type":"NodeText","Data":"INTRODUCTION"}]},{"ID":"20250513180516-q8mhr05","Type":"NodeParagraph","Properties":{"id":"20250513180516-q8mhr05","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"因此，与传统软件一样，安全和安全关键的DL系统必须针对不同的角落情况进行系统的测试，以理想地检测和修复任何潜在的缺陷或不希望的行为。这提出了一个新的系统问题，即对具有成千上万个神经元和数百万个参数的大规模、真实世界的DL系统进行自动化和系统化的测试是极具挑战性的"}]},{"ID":"20250513180516-q82jiph","Type":"NodeParagraph","Properties":{"id":"20250513180516-q82jiph","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"测试DL系统的标准方法是收集并手动标记尽可能多的真实测试数据[ 1、3]。一些DL系统如谷歌自动驾驶汽车也使用仿真生成合成训练数据[ 4 ]。然而，这种模拟完全是无指导的，因为它不考虑目标DL系统的内部。因此，对于真实世界DL系统(例如,自动驾驶汽车的所有可能的路况)的大输入空间，这些方法都不希望覆盖所有可能的角点情况中超过一小部分(如果有的话)。"}]},{"ID":"20250513180516-zug5pvb","Type":"NodeParagraph","Properties":{"id":"20250513180516-zug5pvb","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"最近关于对抗深度学习[ 26、49、72 ]的工作已经证明，通过在现有图像中添加最小扰动来精心制作的合成图像可以欺骗最先进的DL系统。其核心思想是创建合成图像，使它们通过DL模型得到的分类与原始图像不同，但仍然与人眼相同。虽然这种对抗图像暴露了DL模型的一些错误行为，但这种方法的主要限制是必须将其扰动限制在微小的不可见变化或需要人工检查。此外，与现有的DL测试的其他形式一样，对抗图像仅覆盖了DL系统逻辑的一小部分( 52.3 % )，如§ 6所示。从本质上讲，目前用于发现错误拐角案例的机器学习测试实践类似于通过使用代码覆盖率低的测试输入来发现传统软件中的缺陷，因此不太可能发现许多错误案件。"}]},{"ID":"20250513180516-7qgv6a5","Type":"NodeParagraph","Properties":{"id":"20250513180516-7qgv6a5","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"大规模DL系统自动化系统测试的关键挑战有两个方面：( 1 )如何生成触发DL系统逻辑不同部分的输入并揭示不同类型的错误行为；( 2 )如何在不需要人工标记/检查的情况下识别DL系统的错误行为。（考虑MT）本文介绍了我们如何设计和构建DeepXplore来解决这两个挑战。"}]},{"ID":"20250513180516-9sj7uxc","Type":"NodeParagraph","Properties":{"id":"20250513180516-9sj7uxc","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"首先，我们引入神经元覆盖率的概念，根据输入激活(即输出值均高于某一阈值)的神经元数量来衡量一组测试输入执行DL系统逻辑的部分。在高水平上，DL系统的神经元覆盖率类似于传统系统的代码覆盖率，它是衡量传统软件中输入所执行的代码量的标准经验度量。然而，代码覆盖率本身并不是评估DL系统覆盖率的良好指标，因为与传统软件不同，DL系统中的大多数规则不是由程序员手动编写的，而是从训练数据中学习得到的。事实上，我们发现对于我们测试的大多数DL系统，即使单个随机挑选的测试输入也能够实现100 %的代码覆盖率，而神经元覆盖率不到10 %。"}]},{"ID":"20250513180516-usoevb7","Type":"NodeParagraph","Properties":{"id":"20250513180516-usoevb7","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"接下来，我们展示了多个具有相似功能的DL系统(例如,谷歌、特斯拉和通用汽车的自动驾驶汽车)如何作为交叉引用oracle来识别错误的角点情况，而无需人工检查。例如，如果一辆无人驾驶汽车决定向左转，而其他人为了同样的输入而向右转，那么其中一个很可能是不正确的。这种差异测试技术在过去已经成功地应用于检测各种传统软件[ 6、11、14、15、45、86]中没有人工规范的逻辑错误。在本文中，我们演示了如何将差分测试（考虑替换为MT）应用于DL系统。"}]},{"ID":"20250513180516-o0ian6e","Type":"NodeParagraph","Properties":{"id":"20250513180516-o0ian6e","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"最后，我们演示了如何将生成测试输入以最大化DL系统的神经元覆盖率同时暴露尽可能多的差分行为(即多个相似DL系统之间的差异)的问题建模为一个联合优化问题。与传统程序不同，DL系统使用的最流行的深度神经网络( Deep Neural Networks，DNNs )所逼近的函数是可微的。因此，它们关于输入的梯度可以在白盒访问相应模型的情况下精确计算。在本文中，我们展示了如何使用这些梯度来有效地解决上述大规模实际DL系统的联合优化问题。"}]},{"ID":"20250513180516-cd8wcyu","Type":"NodeParagraph","Properties":{"id":"20250513180516-cd8wcyu","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"据我们所知，DeepXplore是第一个面向大规模DL系统的高效白盒测试框架。除了最大化神经元覆盖率和DL系统之间的行为差异外，DeepXplore还支持用户添加自定义约束来模拟不同类型的现实输入(例如,图像/视频的不同类型的照明和遮挡)。我们证明了DeepXplore在15个最先进的DL模型中有效地发现了成千上万的独特的错误拐角案例行为(例如,自动驾驶汽车撞上护栏)，这些数据集包括优达学城自动驾驶汽车挑战数据，来自ImageNet和MNIST的图像数据，来自Drebin的Android恶意软件数据，以及来自Contagio / VirusTotal的PDF恶意软件数据。"}]},{"ID":"20250513180516-iod3lii","Type":"NodeParagraph","Properties":{"id":"20250513180516-iod3lii","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"对于所有被测试的深度学习模型，DeepXplore平均在一台商品笔记本电脑上运行时，会在1秒内产生一个错误行为的测试输入。DeepXplore生成的输入比相同数量的随机抽取输入和对抗输入[ 26、49、72 ]分别平均提高了34.4 %和33.2 %的神经元覆盖率。我们进一步表明，DeepXplore生成的测试输入可以用于重新训练相应的DL模型，以提高分类精度，并识别潜在污染的训练数据。我们通过在DeepXplore生成的输入上重新训练DL模型，与在相同数量的随机或对抗输入上重新训练相比，在分类准确率上实现了高达3 %的提升。"}]},{"ID":"20250513180516-ffdygc9","Type":"NodeParagraph","Properties":{"id":"20250513180516-ffdygc9","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"我们的主要贡献是：·我们引入神经元覆盖率作为DL系统的第一个白盒测试度量，它可以估计由一组测试输入探索的DL逻辑的数量。·我们证明了在最大化神经元覆盖率的同时寻找相似DL系统之间的大量行为差异的问题可以被表述为一个联合优化问题。我们提出了一种基于梯度的算法来有效地解决这个问题。•作为DeepXplore的一部分，我们实现了所有这些技术。DeepXplore是第一个白盒DL -测试框架，它在15个最新的DL模型中暴露了成千上万的错误角点行为(例如,自动驾驶汽车撞入护栏,如图1所示)，共有132，057个神经元，在5个流行的数据集(包含约162 GB的数据)上训练。·我们表明，DeepXplore生成的测试也可以用于重新训练相应的DL系统，以提高高达3 %的分类精度。"}]},{"ID":"20250513180516-sp6wiz0","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513180516-sp6wiz0","updated":"20250513180550"},"Children":[{"Type":"NodeText","Data":"BACKGROUND"}]},{"ID":"20250513180516-exljvg3","Type":"NodeList","ListData":{},"Properties":{"id":"20250513180516-exljvg3","updated":"20250513180516"},"Children":[{"ID":"20250513180516-2w51nab","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180516-2w51nab","updated":"20250513180516"},"Children":[{"ID":"20250513180516-fffxazz","Type":"NodeParagraph","Properties":{"id":"20250513180516-fffxazz","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"DL Systems"}]}]}]},{"ID":"20250513180516-iywifow","Type":"NodeParagraph","Properties":{"id":"20250513180516-iywifow","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"我们将DL系统定义为至少包含一个深度神经网络( Deep Neural Network，DNN )组件的软件系统。需要注意的是，有些DL系统可能仅由DNNs (例如,无人驾驶汽车DNN预测转向角,无需任何手动规则)组成，而另一些DL系统可能有一些DNN组件与其他传统软件组件交互以产生最终输出。"}]},{"ID":"20250513180516-lclxqp7","Type":"NodeParagraph","Properties":{"id":"20250513180516-lclxqp7","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"DL系统的DNN组件的开发过程与传统软件开发有着本质的区别。不同于传统软件中开发人员直接指定系统的逻辑，DNN组件从数据中自动学习其规则。DNN组件的开发者可以通过修改训练数据、特征以及模型的架构细节(例如,层数)来间接影响DNN学习到的规则，如图2所示。"}]},{"ID":"20250513180516-j6nowfb","Type":"NodeParagraph","Properties":{"id":"20250513180516-j6nowfb","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513180516-wvkbifb.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513180516-b1v3okn","Type":"NodeParagraph","Properties":{"id":"20250513180516-b1v3okn","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"由于DNN的规则即使对其开发人员来说也是未知的，因此测试和修复DNN的错误行为在安全关键设置中至关重要。在本文中，我们主要关注在DL系统中自动寻找引发错误行为的输入，并提供初步的证据，说明这些输入如何通过增加或过滤§ 7.3中的训练数据来修复错误行为。"}]},{"ID":"20250513180516-z0d49ju","Type":"NodeList","ListData":{},"Properties":{"id":"20250513180516-z0d49ju","updated":"20250513180516"},"Children":[{"ID":"20250513180516-v606uqg","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180516-v606uqg","updated":"20250513180516"},"Children":[{"ID":"20250513180516-e0qtkmh","Type":"NodeParagraph","Properties":{"id":"20250513180516-e0qtkmh","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"DNN Architecture"}]}]}]},{"ID":"20250513180516-wttay0o","Type":"NodeParagraph","Properties":{"id":"20250513180516-wttay0o","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"DNNs的灵感来自于拥有数百万个相互连接的神经元的人脑。它们以其惊人的能力从原始输入中自动识别和提取相关的高级特征而闻名，除了有标签的训练数据外，没有任何人类的指导。近年来，由于大数据集[ 20、38、47]、专用硬件[ 34、50]和高效训练算法[ 31,39,66,71]的可用性不断提高，DNNs在许多应用领域已经超越了人类的性能。"}]},{"ID":"20250513180516-xhgfzb1","Type":"NodeParagraph","Properties":{"id":"20250513180516-xhgfzb1","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513180516-xpsn48c.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513180516-ypb4j7p","Type":"NodeParagraph","Properties":{"id":"20250513180516-ypb4j7p","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"一个DNN由多个层组成，每个层包含多个神经元，如图3所示。一个神经元是DNN中的一个单独的计算单元，它在其输入上应用激活函数，并将结果传递给其他连接的神经元(见图3)。常用的激活函数包括Sigmoid、双曲正切或ReLU (校正线性单元) [ 48 ]。一个DNN通常至少有三个(往往更多)层：一个输入，一个输出和一个或多个隐藏层。一层中的每个神经元都与下一层的神经元有有向连接。在不同的DNN中，每层神经元的数量和它们之间的连接都有很大的差异。总的来说，一个DNN在数学上可以定义为一个多输入、多输出的参数化函数F，由许多代表不同神经元的参数化子函数组成。"}]},{"ID":"20250513180516-9sopkq1","Type":"NodeParagraph","Properties":{"id":"20250513180516-9sopkq1","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"DNN中神经元之间的每一个连接都被绑定到一个表征神经元之间连接强度的权重参数上。对于监督学习，在训练过程中通过最小化训练数据上的代价函数来学习连接的权重。DNNs可以使用不同的训练算法进行训练，但使用反向传播的梯度下降是迄今为止DNNs最流行的训练算法[ 60 ]。"}]},{"ID":"20250513180516-sfrephf","Type":"NodeParagraph","Properties":{"id":"20250513180516-sfrephf","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513180516-s3tg9sx.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513180516-m900oox","Type":"NodeParagraph","Properties":{"id":"20250513180516-m900oox","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"网络的每一层都将其输入中包含的信息转化为数据更高层次的表示。例如，考虑一个预训练的网络，如图4b所示，用于将图像分类为两类：人脸和汽车。最初的几个隐藏层将原始像素值转化为边缘或颜色等低级纹理特征，并将其馈送到更深的层[ 87 ]。最后几层依次提取并组装鼻子、眼睛、轮子、前灯等有意义的高层抽象来进行分类决策。"}]},{"ID":"20250513180516-o17rbr8","Type":"NodeList","ListData":{},"Properties":{"id":"20250513180516-o17rbr8","updated":"20250513180516"},"Children":[{"ID":"20250513180516-s8myxlf","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180516-s8myxlf","updated":"20250513180516"},"Children":[{"ID":"20250513180516-skq91e2","Type":"NodeParagraph","Properties":{"id":"20250513180516-skq91e2","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"现有DNN检验的局限性"}]}]}]},{"ID":"20250513180516-tmcy8m7","Type":"NodeParagraph","Properties":{"id":"20250513180516-tmcy8m7","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"昂贵的标注工作。现有的DNN测试技术需要耗费巨大的人力来为目标任务(例如,自动驾驶汽车、图像分类、恶意软件检测等)提供正确的标签/动作。对于复杂且高维的真实世界输入，人类，甚至是领域专家，往往很难在大数据集上高效地正确地执行任务。例如，考虑设计一个DNN来识别潜在的恶意可执行文件。即使是安全专业人员，在不执行可执行文件的情况下，也很难判断可执行文件是恶意的还是良性的。然而，在沙箱中执行和监控恶意软件会带来显著的性能开销，因此使得手工标注很难扩展到大量的输入。"}]},{"ID":"20250513180516-gz01sqp","Type":"NodeParagraph","Properties":{"id":"20250513180516-gz01sqp","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"测试覆盖率低。现有的DNN测试方案都没有尝试覆盖DNN的不同规则。因此，测试输入往往无法揭示DNN的不同错误行为。"}]},{"ID":"20250513180516-unzauvl","Type":"NodeParagraph","Properties":{"id":"20250513180516-unzauvl","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"例如，DNNs的测试通常是将整个数据集简单地划分为两个随机部分，一个用于训练，另一个用于测试。在这种情况下，测试集可能只执行一个DNN学习到的所有规则的一个小子集。最近针对DNN的对抗规避攻击的结果已经证明了一些角落情况的存在，其中基于DNN的图像分类器(在随机挑选的测试集上具有最先进的性能)仍然错误地对测试图像[ 26、29、52、63、79、85]添加人类不可察觉的扰动生成的合成图像进行分类。然而，与随机测试输入类似，对抗输入也只覆盖了DNN学习到的一小部分规则，因为它们并不是为了最大化覆盖率而设计的。此外，它们也固有地局限于测试输入周围微小的不可觉察的扰动，因为较大的扰动会在视觉上改变输入，因此需要人工检查以确保DNN决策的正确性。"}]},{"ID":"20250513180516-t3u4vhb","Type":"NodeParagraph","Properties":{"id":"20250513180516-t3u4vhb","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"低覆盖率DNN测试存在的问题。为了更好地理解DNN学习到的规则的测试覆盖率低的问题，我们提供了一个测试传统软件中类似问题的类比。图4展示了一个传统程序和一个DNN如何处理输入和产生输出的并排比较。具体来说，该图显示了传统软件和DNN之间的相似性：在软件程序中，每个语句执行一定的操作，将上一个语句的输出转换为下一个语句的输入，而在DNN中，每个神经元将上一个神经元的输出转换为下一个神经元的输入。当然，与传统软件不同的是，DNN没有显式的分支，而是一个神经元对下游神经元的影响随着神经元输出值的降低而减小。产值越低，影响越小，反之亦然。当一个神经元的输出值变为0时，该神经元对下游神经元没有任何影响。"}]},{"ID":"20250513180516-w09w22w","Type":"NodeParagraph","Properties":{"id":"20250513180516-w09w22w","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"如图4a所示，传统软件测试覆盖率低的问题是显而易见的。在这种情况下，除非测试输入为0xdeadbeef，否则永远不会看到bug行为。随机选取这样一个值的机会很小。同样，低覆盖率的测试输入也会使DNN的不同行为未被探索。例如，考虑一个简化的神经网络，如图4b所示，它将图像作为输入，并将其分类为两种不同的类别：汽车和人脸。每个神经元(表示为一个节点)中的文本表示该神经元检测到的对象或属性1，每个神经元中的编号为该神经元输出的真实值。数字表示神经元对其输出的信心程度。值得注意的是，对于不可能的神经元组合，随机选择的输入极不可能设置高输出值。因此，即使在执行了大量的随机测试后，许多不正确的DNN行为仍将未被探索。例如，如果一幅图像导致标记为' Nose '和' Red '的神经元产生高输出值，而DNN将输入图像误分类为汽车，那么在常规测试中就不会出现这种行为，因为包含红鼻子的图像(例如,一张小丑的照片)的概率很小。"}]},{"ID":"20250513180516-an5355s","Type":"NodeParagraph","Properties":{"id":"20250513180516-an5355s","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"OVERVIEW"}]},{"ID":"20250513180516-4mhrkni","Type":"NodeParagraph","Properties":{"id":"20250513180516-4mhrkni","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513180516-psusgvg.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513180516-4asi17m","Type":"NodeParagraph","Properties":{"id":"20250513180516-4asi17m","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"在本节中，我们对我们的白盒框架DeepXplore进行了概述，该框架用于系统地测试DNNs的错误角案例行为。DeepXplore的主要组件如图5所示。DeepXplore以未标记的测试输入作为种子，生成覆盖大量神经元(也就是说,将它们激活到一个高于可定制阈值的值)的新测试，同时导致被测试的DNN表现出不同的行为。具体来说，DeepXplore解决了一个同时最大化差分行为和神经元覆盖率的联合优化问题。值得注意的是，这两个目标对于DNN的彻底测试和发现各种错误的角案例行为都至关重要。单独的高神经元覆盖率可能不会诱发许多错误行为，而仅仅最大化不同的行为可能会简单地识别同一潜在根本原因的不同表现。"}]},{"ID":"20250513180516-7swj0u9","Type":"NodeParagraph","Properties":{"id":"20250513180516-7swj0u9","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"作为联合优化过程的一部分，DeepXplore还支持执行自定义的领域特定约束。例如，一个图像像素的值必须在0到255之间。这些特定于领域的约束可以由DeepXplore的用户指定，以确保生成的测试输入是有效且符合实际的。"}]},{"ID":"20250513180516-gxbsfq8","Type":"NodeParagraph","Properties":{"id":"20250513180516-gxbsfq8","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"我们设计了一种利用梯度上升高效求解上述联合优化问题的算法。首先，我们以输入值为变量，权重参数为常数，计算输出层和隐藏层神经元输出的梯度。这样的梯度对于大多数DNN都可以高效地计算。需要注意的是，DeepXplore被设计用于运行在预先训练好的DNN上。梯度计算是有效的，因为我们的白盒方法可以获得预训练的DNN的权重和中间神经元值。接下来，我们迭代地执行梯度上升来修改测试输入，以使上述联合优化问题的目标函数最大化。本质上，我们从种子输入开始执行梯度引导的局部搜索，并找到使期望目标最大化的新输入。需要注意的是，在较高的层次上，我们的梯度计算类似于DNN训练过程中的反向传播，但关键的区别在于，与我们的算法不同，反向传播将输入值视为常数，权重参数视为变量。"}]},{"ID":"20250513180516-6cp5z2h","Type":"NodeParagraph","Properties":{"id":"20250513180516-6cp5z2h","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513180516-0ve9oxw.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513180516-t8z0ydf","Type":"NodeParagraph","Properties":{"id":"20250513180516-t8z0ydf","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"工作实例。我们以图6为例展示DeepXplore如何生成测试输入。考虑我们有两个DNN来测试- -都执行类似的任务，即将图像分类为汽车或人脸，如图6所示，但它们是用不同的数据集和参数独立训练的。DNNs将学习相似但略有不同的分类规则。同样假设我们有一个种子测试输入，一辆红色汽车的图像，两个DNN都识别为汽车，如图6a所示（此部分可使用不确定性的概率识别，即不通过DNN的结果判断，而是通过概率分布判断）。"}]},{"ID":"20250513180516-q7oz37i","Type":"NodeParagraph","Properties":{"id":"20250513180516-q7oz37i","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"DeepXplore通过修改输入，即红色汽车的图像来最大化其被一个DNN分类为汽车的概率，同时最小化另一个DNN的相应概率，从而最大化发现差异行为的机会。DeepXplore还试图通过激活隐藏层中的(即,使神经元的输出具有大于阈值的值)非活性神经元来覆盖尽可能多的神经元。我们进一步添加了特定领域的约束(例如,对于图像输入,确保像素值在0和255以内的整数)，以确保修改后的输入仍然代表真实世界的图像。联合优化算法将迭代进行梯度上升，以找到满足上述所有目标的修正输入。DeepXplore最终将生成一组DNN不同测试输入的输出，例如，一个DNN认为它是一辆车，而另一个DNN认为它是一张脸，如图6b所示。"}]},{"ID":"20250513180516-q9p0qwt","Type":"NodeParagraph","Properties":{"id":"20250513180516-q9p0qwt","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513180516-w4cig6l.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513180516-xplrxzi","Type":"NodeParagraph","Properties":{"id":"20250513180516-xplrxzi","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"图7展示了我们使用梯度提升技术的基本概念。DeepXplore从一个种子输入开始，在两个相似的DNN的输入空间中进行梯度引导搜索，以执行相同的任务，最终发现位于这些DNN决策边界之间的测试输入。这样的测试输入将由两个DNN进行不同的分类。值得注意的是，虽然梯度提供了通向目标(例如,寻找引起差异的投入)的大致方向，但它并不能保证最快的收敛速度。因此，如图7所示，梯度上升过程往往不是沿着一条直线路径到达目标。"}]},{"ID":"20250513180516-vk4tj75","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250513180516-vk4tj75","updated":"20250513180551"},"Children":[{"Type":"NodeText","Data":"METHODOLOGY"}]},{"ID":"20250513180516-wbiw5b0","Type":"NodeList","ListData":{},"Properties":{"id":"20250513180516-wbiw5b0","updated":"20250513180516"},"Children":[{"ID":"20250513180516-mod6fng","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180516-mod6fng","updated":"20250513180516"},"Children":[{"ID":"20250513180516-dxetcbm","Type":"NodeParagraph","Properties":{"id":"20250513180516-dxetcbm","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"定义"}]}]}]},{"ID":"20250513180516-0l7wx8v","Type":"NodeParagraph","Properties":{"id":"20250513180516-0l7wx8v","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"神经元覆盖率。我们定义一组测试输入的神经元覆盖率为所有测试输入的唯一激活神经元数量与DNN中总神经元数量的比值。我们认为如果一个神经元的输出高于阈值(例如, 0)，那么它将被激活。更严格地说，假设DNN的所有神经元由集合N "},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"="}]},{"Type":"NodeText","Data":" { n1，n2，.. }表示，所有测试输入由集合T "},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"="}]},{"Type":"NodeText","Data":" { x1，x2，.. }表示，并且对于给定的测试输入x，out( n , x)是一个返回DNN中神经元n的输出值的函数。注意，加粗的x表示x为向量。令t表示考虑一个神经元被激活的阈值。在这种情况下，神经元覆盖率可以定义如下："}]},{"ID":"20250513180516-9pm2n23","Type":"NodeParagraph","Properties":{"id":"20250513180516-9pm2n23","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513180516-orv7hpp.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513180516-zmwxvn3","Type":"NodeParagraph","Properties":{"id":"20250513180516-zmwxvn3","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"为了说明实际中神经元覆盖率是如何计算的，考虑图4b所示的DNN。图4b所示红色小车输入图片的神经元覆盖率(以阈值0)为5 / 8 "},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"="}]},{"Type":"NodeText","Data":" 0.625。"}]},{"ID":"20250513180516-2n3k26q","Type":"NodeParagraph","Properties":{"id":"20250513180516-2n3k26q","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"梯度。DNN的神经元输出关于输入的梯度或前向导数在深度学习文献中众所周知。它们已被广泛用于生成对抗样本[ 26,29,52,72]和可视化/理解DNNs [ 44,65,87]。为了完整起见，我们在这里给出了一个简单的定义，更多细节请参考[ 87 ]。"}]},{"ID":"20250513180516-i9wprva","Type":"NodeParagraph","Properties":{"id":"20250513180516-i9wprva","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"令θ和x分别表示DNN的参数和测试输入。神经元执行的参数函数可以表示为y "},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"="}]},{"Type":"NodeText","Data":" f ( θ , x)，其中f是以θ和x作为输入和输出y的函数。注意y可以是DNN (例如,来自输出层或中间层的神经元)中定义的任意神经元的输出。f( θ , x)关于输入x的梯度可以定义为："}]},{"ID":"20250513180516-xslar0n","Type":"NodeParagraph","Properties":{"id":"20250513180516-xslar0n","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513180516-4vgwbno.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513180516-6xehjys","Type":"NodeParagraph","Properties":{"id":"20250513180516-6xehjys","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"f内部的计算本质上是一系列堆叠的函数，它们计算前一层的输入并将输出转发到下一层。因此，可以利用微积分中的链式法则计算G，即从输出y的神经元层开始计算逐层导数，直到到达以x为输入的输入层。注意到梯度G的维数与输入x的维数相同。"}]},{"ID":"20250513180516-duwm21b","Type":"NodeList","ListData":{},"Properties":{"id":"20250513180516-duwm21b","updated":"20250513180516"},"Children":[{"ID":"20250513180516-5yydy1y","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250513180516-5yydy1y","updated":"20250513180516"},"Children":[{"ID":"20250513180516-ppech9v","Type":"NodeParagraph","Properties":{"id":"20250513180516-ppech9v","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"DeepXplore算法"}]}]}]},{"ID":"20250513180516-0ud427d","Type":"NodeParagraph","Properties":{"id":"20250513180516-0ud427d","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"与传统软件相比，DNN的测试输入生成过程的主要优点是，测试生成过程一旦被定义为一个优化问题，就可以使用梯度上升来有效地解决。在本节中，我们描述了优化问题的公式和寻找解决方案的细节。值得注意的是，优化问题的解可以有效地找到DNNs，因为DNNs的目标函数的梯度，不同于传统的软件，可以很容易地计算。"}]},{"ID":"20250513180516-ghvrzf8","Type":"NodeParagraph","Properties":{"id":"20250513180516-ghvrzf8","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"如前文§ 3所述，测试生成过程的目标是在保持用户提供的特定领域约束的同时，最大化观察到的差异行为的数量和神经元覆盖率。算法1给出了通过求解该联合优化问题生成测试输入的算法。下面，我们正式定义了联合优化问题的目标，并解释了求解该问题的算法细节。"}]},{"ID":"20250513180516-gwdc32n","Type":"NodeParagraph","Properties":{"id":"20250513180516-gwdc32n","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250513180516-ltv0j7w.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250513180516-liuepp9","Type":"NodeParagraph","Properties":{"id":"20250513180516-liuepp9","updated":"20250513180516"},"Children":[{"Type":"NodeText","Data":"最大化差异行为。该优化问题的第一个目标是生成能够在被测DNN中诱发不同行为的测试输入，即不同的DNN将相同的输入分类到不同的类中。假设我们有n个DNNs Fk∈1 .. n：x→y，其中Fk是由第k个神经网络建模的函数，x代表输入，y代表输出类概率向量。给定一个任意的x作为种子被所有DNN分类到同一个类，我们的目标是修改x，使得修改后的输入x′将被n个DNN中的至少一个不同地分类。"}]}]}