{"ID":"20250620161103-riifff0","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f4d1","id":"20250620161103-riifff0","title":"符号执行","type":"doc","updated":"20250620162910"},"Children":[{"ID":"20250620161149-ctd9zm8","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250620161149-ctd9zm8","updated":"20250620162910"},"Children":[{"Type":"NodeText","Data":"符号执行入门"}]},{"ID":"20250620161149-o3coxle","Type":"NodeParagraph","Properties":{"id":"20250620161149-o3coxle","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"那么什么是符号执行（symbolic execution）技术呢？Wiki中的定义是：在计算机科学中，符号执行技术指的是通过程序分析的方法，确定哪些输入向量会对应导致程序的执行结果向量的方法。通俗的说，如果把一个程序比作DOTA英雄，英雄的最终属性值为程序的输出（包括攻击力、防御力、血槽、蓝槽），英雄的武器出装为程序的输入（出A杖还是BKB）。那么符号执行技术的任务就是，给定了一个英雄的最终属性值，分析出该英雄可以通过哪些出装方式达到这种最终属性值效果。（咚咚咚！LGD明年还会回来的！）"}]},{"ID":"20250620162404-6fqxtgz","Type":"NodeParagraph","Properties":{"id":"20250620162404-6fqxtgz","updated":"20250620162404"},"Children":[{"Type":"NodeText","Data":"符号执行的思想很简单，计算机程序的分支结构都是二元的，循环和 switch 这样的结构，最后也会转换成二元分支。在二元分支上，选择路径时，都会根据特定的约束条件判断应该执行哪个分支，如果我们能够求出输入在什么取值下可以使约束条件成立，在什么取值下可以使约束条件不成立，就可以带着这样的取值条件分别进入两个分支，进而在碰到所有的分支都可以获得进入这个分支时的输入取值范围和路上被赋值的变量的取值范围。这样我们可以做到："}]},{"ID":"20250620162404-jzbke14","Type":"NodeList","ListData":{},"Properties":{"id":"20250620162404-jzbke14","updated":"20250620162404"},"Children":[{"ID":"20250620162404-qnkon3f","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250620162404-qnkon3f","updated":"20250620162404"},"Children":[{"ID":"20250620162404-wq3p5k2","Type":"NodeParagraph","Properties":{"id":"20250620162404-wq3p5k2","updated":"20250620162404"},"Children":[{"Type":"NodeText","Data":"求出几组输入，这些输入可以让程序执行完所有可执行的路径，让我们获得很高的测试的覆盖率"}]}]},{"ID":"20250620162404-eap2uf9","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250620162404-eap2uf9","updated":"20250620162404"},"Children":[{"ID":"20250620162404-v4uxcat","Type":"NodeParagraph","Properties":{"id":"20250620162404-v4uxcat","updated":"20250620162404"},"Children":[{"Type":"NodeText","Data":"求出每个变量在特定位置的取值范围，这样在变量用于危险操作，如做数组下标的时候，就可以判断可不可能出现越界访问"}]}]}]},{"ID":"20250620162537-hwh61gq","Type":"NodeBlockquote","Properties":{"id":"20250620162537-hwh61gq","updated":"20250620162910"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20250620162602-xxxhecc","Type":"NodeParagraph","Properties":{"id":"20250620162602-xxxhecc","updated":"20250620162743"},"Children":[{"Type":"NodeText","Data":"使用符号值执行程序，最终可以表示为一组路径条件与对应的符号表达式状态的二元组"}]},{"ID":"20250620162814-c03bo9q","Type":"NodeList","ListData":{},"Properties":{"id":"20250620162814-c03bo9q","updated":"20250620162910"},"Children":[{"ID":"20250620162814-pt2rf84","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250620162814-pt2rf84","updated":"20250620162910"},"Children":[{"ID":"20250620162814-rvicf2g","Type":"NodeMathBlock","Properties":{"id":"20250620162814-rvicf2g","updated":"20250620162833"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent"},{"Type":"NodeMathBlockCloseMarker"}]}]}]}]},{"ID":"20250620161149-evpxhds","Type":"NodeParagraph","Properties":{"id":"20250620161149-evpxhds","updated":"20250620161343"},"Children":[{"Type":"NodeText","Data":"可以发现，符号执行技术是一种"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);"},"TextMarkType":"text","TextMarkTextContent":"白盒的静态分析技术"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);\"}"},{"Type":"NodeText","Data":"，即分析程序可能的输入需要能够获取到目标源代码的支持。同时，它是静态的，因为并没有实际的执行程序本身，而是分析程序的执行路径。如果把上述英雄的最终属性值替换成程序形成的bug状态，比如，存在数组越界复制的状态，那么，我们就能够利用此技术挖掘漏洞的输入向量了。"}]},{"ID":"20250620161149-qp198wr","Type":"NodeParagraph","Properties":{"id":"20250620161149-qp198wr","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"这里再举一个简单的例子，让大家有深刻的理解。\n以下面的源代码为例子："}]},{"ID":"20250620161149-o62v0gd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250620161149-o62v0gd","updated":"20250620161149"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y29ib2w="},{"Type":"NodeCodeBlockCode","Data":"int m=M, n=N, q=Q; \nint x1=0,x2=0,x3=0;\nif(m!=0)\n{\n    x1=-2;\n}\nif(n\u003c12)\n{\n    if(!m \u0026\u0026 q)\n    {\n        x2=1;\n    }\n    x3=2;\n}\nassert(x1+x2+x3!=3)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250620161149-hs0zw9b","Type":"NodeParagraph","Properties":{"id":"20250620161149-hs0zw9b","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"上述代码是一个简单的c语言分支结构代码，它的输入是M,N,Q三个变量；输出是x1,x2,x3的三个变量的和。我们这里设置的条件是想看看什么样的输入向量"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003c"}]},{"Type":"NodeText","Data":"M,N,Q"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003e"}]},{"Type":"NodeText","Data":"的情况下，得到的三个输出变量的和等于3. 那么我们通过下面的树形结构来看看所有的情况："}]},{"ID":"20250620161149-esauqaq","Type":"NodeParagraph","Properties":{"id":"20250620161149-esauqaq","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/44d2bf6e71e346ab84bf1f7ff7d41ec3.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://i-blog.csdnimg.cn/blog_migrate/44d2bf6e71e346ab84bf1f7ff7d41ec3.png","TextMarkTextContent":"https://i-blog.csdnimg.cn/blog_migrate/44d2bf6e71e346ab84bf1f7ff7d41ec3.png"}]},{"ID":"20250620161149-ay8ko3k","Type":"NodeParagraph","Properties":{"id":"20250620161149-ay8ko3k","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"上面的分析图把所有可能的情况都列举出来了，其中，叶子节点显示的数值表示当前输入情况下，可以得到的数值。（比如，如果英雄出装是M"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"^"}]},{"Type":"NodeText","Data":"(N"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003c"}]},{"Type":"NodeText","Data":"12)，那么最终的属性值R"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"="}]},{"Type":"NodeText","Data":"0）。其中M"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"^"}]},{"Type":"NodeText","Data":"(N"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003c"}]},{"Type":"NodeText","Data":"12)表达的是，M是非零值且N要小于12，Q为任意值的情况下，得到R"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"="}]},{"Type":"NodeText","Data":"0。可以发现，当条件为"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"~"}]},{"Type":"NodeText","Data":"M"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"^"}]},{"Type":"NodeText","Data":"(N"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003c"}]},{"Type":"NodeText","Data":"5)"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"^"}]},{"Type":"NodeText","Data":"Q时，得到了最终结果等于3.即，我们通过这种方式逆向发现了输入向量。如果把结果条件更改为漏洞条件，理论上也是能够进行漏洞挖掘了。"}]},{"ID":"20250620161149-b6g9ji8","Type":"NodeParagraph","Properties":{"id":"20250620161149-b6g9ji8","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"对于如何根据最终得到的结果求解输入向量，已经有很多现成的数学工具可以使用。上述问题其实可以规约成约束规划的求解问题（更详细的介绍看这里："},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://en.wikipedia.org/wiki/Constraint_programming","TextMarkTextContent":"Constraint_programming"},{"Type":"NodeText","Data":" ）。比较著名的工具比如SMT（Satisfiability Modulo Theory，可满足性模理论）和SAT。"}]},{"ID":"20250620161149-10v8v9u","Type":"NodeParagraph","Properties":{"id":"20250620161149-10v8v9u","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"但是在实际的漏洞分析过程中，目标程序可能更加复杂，没有我们上面的例子这么简单。实际的程序中，可能包含了与外设交互的系统函数，而这些系统函数的输入输出并不会直接赋值到符号中，从而阻断了此类问题的求解。比如下面的这个包含了文件读写的例子："}]},{"ID":"20250620161149-bdkssy2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250620161149-bdkssy2","updated":"20250620161149"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y29ib2w="},{"Type":"NodeCodeBlockCode","Data":"int main(int argc, char* argv[])\n{\n    FILE *fop = fopen(\"test.txt\");\n    ...\n    if(argc \u003e 3)\n    {\n        fputs(\"Too many parameters, exit.\", fop);\n    }\n    else\n    {\n        fputs(\"Ok, we will run normally.\", fop);\n    }\n    ...\n    output = fgets(..., fop);\n    assert(！strcmp(output, \"Ok, we will run normally.\"));\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250620161149-q41pu00","Type":"NodeParagraph","Properties":{"id":"20250620161149-q41pu00","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"上述示例代码中，想要发现什么情况下会得到输出”Ok, we will run normally.”这个字符串。通过一系列的执行到if语句，此时，根据输入的参数个数将会产生两个分支。分支语句中将执行系统的文件写操作。在传统的符号执行过程中，此类函数如果继续沿着系统函数的调用传递下去的话，符号数值的传递将会丢失。而在之后的output "},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"="}]},{"Type":"NodeText","Data":" fgets(…, fop);这行代码中，符号从外部获得的数值也将无法正常的赋值到output中。因此，符号执行无法求解上述问题，因为在调用系统函数与外设交互的时候，符号数值的赋值过程被截断了。"}]},{"ID":"20250620161149-xam0534","Type":"NodeParagraph","Properties":{"id":"20250620161149-xam0534","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/f95b79224578b4b7e122692c5f6ae58c.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://i-blog.csdnimg.cn/blog_migrate/f95b79224578b4b7e122692c5f6ae58c.png","TextMarkTextContent":"https://i-blog.csdnimg.cn/blog_migrate/f95b79224578b4b7e122692c5f6ae58c.png"}]},{"ID":"20250620161149-ppeaccy","Type":"NodeParagraph","Properties":{"id":"20250620161149-ppeaccy","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"为了解决这个问题，最经典的项目就是基于LLVM的KLEE（"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://github.com/klee/klee","TextMarkTextContent":"klee"},{"Type":"NodeText","Data":")它把一系列的与外设有关的系统函数给重新写了一下，使得符号数值的传递能够继续下去。从比较简化的角度来说，就是把上面的fputs函数修改成，字符串赋值到某个变量中，比如可以是上面的fop里面。再把fgets函数修改成从某个变量获取内容，比如可以是把fop的地址给output。这样，就能够把符号数值的传递给续上。当然，这里举的例子是比较简单的例子，实际在重写函数的时候，会要处理更复杂的情况。在KLEE中，它重新对40个系统调用进行了建模，比如open, read, write, stat, lseek, ftruncate, ioctl。感兴趣的读者可以进一步阅读他们发表在OSDI2008年的论文（"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://www.anquanke.com/post/id/llvm.org/pubs/2008-12-OSDI-KLEE.pdf","TextMarkTextContent":"KLEE-OSDI08"},{"Type":"NodeText","Data":")他们的文章深入浅出，非常适合学习。"}]},{"ID":"20250620161149-6qqkjbq","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250620161149-6qqkjbq","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"符号执行上高速"}]},{"ID":"20250620161149-6s58kkv","Type":"NodeParagraph","Properties":{"id":"20250620161149-6s58kkv","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"近几年，由于物联网设备逐渐的大众化，嵌入式设备的漏洞挖掘需求更加显著。那么在嵌入式的环境下，使用符号执行技术挖掘漏洞可行吗？答案是肯定的。但，需要解决的问题除了类似于KLEE中出现的与外设交互的系统调用建模以外，还需要解决嵌入式设备中经常出现的混合代码情况。即，给出的嵌入式源代码中，有c语言代码、二进制代码（共享库）和汇编代码。面对这种情况应该如何启用符号执行呢？"}]},{"ID":"20250620161149-apcg1pt","Type":"NodeParagraph","Properties":{"id":"20250620161149-apcg1pt","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"我们来看看下面的基于ARMv7架构的一个例子，"}]},{"ID":"20250620161149-yraxk0q","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250620161149-yraxk0q","updated":"20250620161149"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"unsigned char msg[] = \"world\";\nint index;\n\nvoid uart_send(unsigned char a)\n{\n    __asm volatile(\"SVC #0\");\n    __asm volatile(\"BX LR\");\n}\n\nvoid os_uart_send(){...}\n\nint main(int argc, char* argv[])\n{\n    uart_send(msg[index++]);\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250620161149-4o8spa8","Type":"NodeParagraph","Properties":{"id":"20250620161149-4o8spa8","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"上述嵌入式代码有高级语言的C代码，以及还有ARMv7的汇编代码。嵌入式应用程序中写汇编代码的目的通常是为了使得程序的执行效率更高。该代码的主要作用是通过uart发送消息。函数uart"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"_"}]},{"Type":"NodeText","Data":"send()中，通过指令“SVC #0”切换成SVC的寄存器模式之后，将实际上调用函数os"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"_"}]},{"Type":"NodeText","Data":"uart"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"_"}]},{"Type":"NodeText","Data":"send()发送消息。其中，uart"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"_"}]},{"Type":"NodeText","Data":"send函数的参数将直接在os"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"_"}]},{"Type":"NodeText","Data":"uart"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"_"}]},{"Type":"NodeText","Data":"send()函数中使用。上述代码，通过LLVM转换成LLVM-IR的形式，为下面的代码。"}]},{"ID":"20250620161149-tjcojo5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250620161149-tjcojo5","updated":"20250620161149"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y29ib2w="},{"Type":"NodeCodeBlockCode","Data":"@msg = global [6xi8]c\"world0\"\n@index = global i32 0\n\ndefine void @uart_send(i8 zeroext) #0\n{\n    entry:\n    call void asm sideeffect \"SVC #0\",\"\"()\n    call void asm sideeffect \"BX LR\",\"\"()\n    unreachable\n}\n\ndefine void @os_uart_send(){...}\n\ndefine int @main() #1\n{\n    entry:\n    %0 = load i32* @index\n    %inc = add nsw i32 %0, 1\n    store i32 %inc, i32* @index\n    %arrayidx = getelementptr inbounds [6xi8]* @msg, i32 0, i32 %0\n    %1 = load i8* %arrayidx\n    call void @uart_send(i8 zeroext %1)\n    ret i32 0\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250620161149-kier3o9","Type":"NodeParagraph","Properties":{"id":"20250620161149-kier3o9","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"为什么要转换成LLVM-IR的代码呢。LLVM-IR是LLVM的一种中间的语言表达形式，也是一种汇编语言的形式。现有的KLEE工具就是LLVM-IR工具实现的符号执行虚拟机。在解释上面的代码之前，简单介绍几个LLVM-IR的基础语法，以便更清楚的理解。"}]},{"ID":"20250620161149-yyef61y","Type":"NodeParagraph","Properties":{"id":"20250620161149-yyef61y","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"LLVM-IR的变量有三种，通过前缀@或者%的形式区分，其中@表示全局变量，%表示局部变量："}]},{"ID":"20250620161149-m9mu2bt","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20250620161149-m9mu2bt","updated":"20250620161149"},"Children":[{"ID":"20250620161149-y9auq9l","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20250620161149-y9auq9l","updated":"20250620161149"},"Children":[{"ID":"20250620161149-ea2ju0s","Type":"NodeParagraph","Properties":{"id":"20250620161149-ea2ju0s","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"%或者@接数字，表示的是临时变量，在一个函数中，从0开始编号使用。比如%0，%1，。。"}]}]},{"ID":"20250620161149-0yxdhw9","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20250620161149-0yxdhw9","updated":"20250620161149"},"Children":[{"ID":"20250620161149-5vcfuun","Type":"NodeParagraph","Properties":{"id":"20250620161149-5vcfuun","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"%或者@接字符串，表示有名字的变量，可以任意使用；"}]}]},{"ID":"20250620161149-un9i6op","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20250620161149-un9i6op","updated":"20250620161149"},"Children":[{"ID":"20250620161149-3tnr2q1","Type":"NodeParagraph","Properties":{"id":"20250620161149-3tnr2q1","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"第三类就是立即数"}]}]}]},{"ID":"20250620161149-8ywhrgn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250620161149-8ywhrgn","updated":"20250620161149"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"bGVzcw=="},{"Type":"NodeCodeBlockCode","Data":"@msg = global [6xi8]c\"world0\"\n@index = global i32 0\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250620161149-h57xhc1","Type":"NodeParagraph","Properties":{"id":"20250620161149-h57xhc1","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"上述代码初始化了全局变量msg和index。"}]},{"ID":"20250620161149-wy4hmaa","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250620161149-wy4hmaa","updated":"20250620161149"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y29ib2w="},{"Type":"NodeCodeBlockCode","Data":"entry:\n%0 = load i32* @index\n%inc = add nsw i32 %0, 1\nstore i32 %inc, i32* @index\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250620161149-9yme2qi","Type":"NodeParagraph","Properties":{"id":"20250620161149-9yme2qi","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"上述代码中，i32表示是32位的类型，i32"},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"表示的指向i32类型的指针类型。%0"},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"="},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"load i32"},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://github.com/index","TextMarkTextContent":"@index"},{"Type":"NodeText","Data":"表示将全局变量index的值赋值给局部变量%0. Add nsw是有符号的相加。再加完之后，又把数值存储回了全局变量index。"}]},{"ID":"20250620161149-e7uio53","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250620161149-e7uio53","updated":"20250620161149"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y29ib2w="},{"Type":"NodeCodeBlockCode","Data":"%arrayidx = getelementptr inbounds [6xi8]* @msg, i32 0, i32 %0\n%1 = load i8* %arrayidx\ncall void @uart_send(i8 zeroext %1)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250620161149-74q73ex","Type":"NodeParagraph","Properties":{"id":"20250620161149-74q73ex","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"上述代码中，[6xi8] 这种形式表示的是数组类型，这里就是含有6个8位的元素的数组。Getelementptr inbounds即使获得数组对应元素的指针。之后利用语句%1 "},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"="}]},{"Type":"NodeText","Data":" load i8"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"*"}]},{"Type":"NodeText","Data":" %arrayidx获取指针指向的8位的值，在传入到函数uart"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"_"}]},{"Type":"NodeText","Data":"send中执行。"}]},{"ID":"20250620161149-4yfh3oi","Type":"NodeParagraph","Properties":{"id":"20250620161149-4yfh3oi","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"可以发现，如果按照已有的KLEE方法，在转换成LLVM-IR代码之后，由于代码中含有arm架构的汇编，而该arm代码中没有明显的调用参数的代码和方式，使得符号数值的传递再次中断，导致KLEE方法不能执行。因此，我们需要对上述含有混合LLVM-IR代码的内存进行再次转化，使得含有低级语意的arm汇编也能够被KLEE的符号执行虚拟机分析。"}]},{"ID":"20250620161149-587aibe","Type":"NodeParagraph","Properties":{"id":"20250620161149-587aibe","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"最近在安全顶会USENIX Security18上发表的论文Inception，正是完成了上面的这件事情。它通过程序分析的方式，将混合油高级语言和低级语言的代码同时转化成KLEE能够分析的语言，从而执行符号执行的分析。根据Inception里面的思想，上述LLVM-IR转化之后，可以有下面的表达形式："}]},{"ID":"20250620161149-kf2xydg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250620161149-kf2xydg","updated":"20250620161149"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y29ib2w="},{"Type":"NodeCodeBlockCode","Data":"@msg = global [6xi8]c\"world0\"\n@index = global i32 0\n\n; stack is stored in global variables\n@R0 = global i32 0, align 4\n@SP = global i32 0, align 4 \n@_SVC_fe = global i32 0, align 4 \n@LR = global i32 0, align 4 \n@.stack = global [8202xi4] zeroinitializer \n\ndefine void @uart_send(i8) #0\n{\n    ; pass the parameters from high level to the low level.\n    entry:\n    %1 = zext i8 %0 to i32\n    store i32 %1, i32* @R0\n    br label %\"uart_send+0\" ; jmp to the actual code\n\n\"uart_send+0\":\n    %SP1 = load i32* @SP ; load the stack pointer\n    store i32 0, iew* @_SVC_fe\n    store i32 268436580, i32* @PC ; store pointer execution\n    call void (...)* @_sv_call()\n    call void (...)* os_uart_send()    ; invoke uart send function and  using the value from the R0\n    %LR1 = load i32* @LR1              ;load return address\n    ret void\n}\n\ndefine void @os_uart_send(){...}\n\ndefine int @main() #1\n{\n    entry:\n    %0 = load i32* @index\n    %inc = add nsw i32 %0, 1\n    store i32 %inc, i32* @index\n    %arrayidx = getelementptr inbounds [6xi8]* @msg, i32 0, i32 %0\n    %1 = load i8* %arrayidx\n    call void @uart_send(i8 zeroext %1)\n    ret i32 0\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250620161149-q53xxd5","Type":"NodeParagraph","Properties":{"id":"20250620161149-q53xxd5","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"可以发现，相比于之前的LLVM-IR。函数uart"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"_"}]},{"Type":"NodeText","Data":"send中多了一部分内容。"}]},{"ID":"20250620161149-24eu9qw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250620161149-24eu9qw","updated":"20250620161149"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y29ib2w="},{"Type":"NodeCodeBlockCode","Data":"; stack is stored in global variables\n@R0 = global i32 0, align 4\n@SP = global i32 0, align 4 \n@_SVC_fe = global i32 0, align 4 \n@LR = global i32 0, align 4 \n@.stack = global [8202xi4] zeroinitializer \n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250620161149-yahyx53","Type":"NodeParagraph","Properties":{"id":"20250620161149-yahyx53","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"这部分代码对于arm汇编中只用的寄存器架构搬移了出来，并且声明成了全局变量的形式，之后，arm在寄存器和栈中的操作，都会转化成在上述全局变量中的操作。"}]},{"ID":"20250620161149-thi7vqh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250620161149-thi7vqh","updated":"20250620161149"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y29ib2w="},{"Type":"NodeCodeBlockCode","Data":"entry:\n%1 = zext i8 %0 to i32\nstore i32 %1, i32* @R0\nbr label %\"uart_send+0\" ; jmp to the actual code\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250620161149-l9lvu6b","Type":"NodeParagraph","Properties":{"id":"20250620161149-l9lvu6b","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"上述代码的主要功能是讲参数msg[i++]获得的值传递给寄存器R0中，这种显示的表达，将使得符号的数值传递串联起来。%1 "},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"="}]},{"Type":"NodeText","Data":" zext i8 %0 to i32表示将参数i8转化成i32。store i32 %1, i32"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"*"}]},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://github.com/R0","TextMarkTextContent":"@R0"},{"Type":"NodeText","Data":"表示将转化后的内容%1存储到寄存器R0中。Br是条件跳转语句，在这里，br将执行无条件跳转到”uart"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"_"}]},{"Type":"NodeText","Data":"send+0”中。"}]},{"ID":"20250620161149-rixytlj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250620161149-rixytlj","updated":"20250620161149"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y29ib2w="},{"Type":"NodeCodeBlockCode","Data":"\"uart_send+0\":\n%SP1 = load i32* @SP ; load the stack pointer\nstore i32 0, iew* @_SVC_fe\nstore i32 268436580, i32* @PC ; store pointer execution\ncall void (...)* @_sv_call()\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250620161149-pyey2qh","Type":"NodeParagraph","Properties":{"id":"20250620161149-pyey2qh","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"上述代码主要为转换arm的寄存器模式为SVC模式。"}]},{"ID":"20250620161149-gh36ch3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250620161149-gh36ch3","updated":"20250620161149"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y29ib2w="},{"Type":"NodeCodeBlockCode","Data":"call void (...)* os_uart_send()    ; invoke uart send function and using the value from the R0\n%LR1 = load i32* @LR1              ;load return address\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250620161149-l2b520v","Type":"NodeParagraph","Properties":{"id":"20250620161149-l2b520v","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"上述内容则调用了函数os"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"_"}]},{"Type":"NodeText","Data":"uart"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"_"}]},{"Type":"NodeText","Data":"send，并使用了参数R0。因此，完成了符号数值的传递。上述寄存器的赋值，以及该系统函数的调用，可以转化成语意为调用了R0参数的函数调用。Arm的函数调用规范见"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042f/IHI0042F_aapcs.pdf","TextMarkTextContent":"ABI"},{"Type":"NodeText","Data":"\n更详细的arm指令可以参考"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"http://infocenter.arm.com/help/topic/com.arm.doc.dui0489i/DUI0489I_arm_assembler_reference.pdf","TextMarkTextContent":"arm"},{"Type":"NodeText","Data":"\nLLVM-IR的参考可以见"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"http://llvm.org/docs/LangRef.html#introduction","TextMarkTextContent":"LLVM-IR"},{"Type":"NodeText","Data":"\nInception项目的安装可以基于docker，使得操作更加简单了"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://github.com/Inception-framework/docker","TextMarkTextContent":"Inception-docker-install"}]},{"ID":"20250620161149-hzxut33","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250620161149-hzxut33","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20250620161149-bek98xs","Type":"NodeParagraph","Properties":{"id":"20250620161149-bek98xs","updated":"20250620161149"},"Children":[{"Type":"NodeText","Data":"总体来说，现有的符号执行工具，在开源方面，主要还是基于KLEE项目的。可见对于KLEE项目的深入理解，将有助于我们打造更加高效的工具。有了高效的工具，就能够使得我们一边学习理论，一遍验证，从而走上高速公路。Inception工具是就ARM架构，而对于路由器中常使用的MIPS架构，就笔者现在所知，现在还尚未有类似的符号执行工具发布（如果已经由类似工具，欢迎读者留言）。其中，基于IDA的脚本工具bugscam，经过揭秘路由器0DAY漏洞的作者修改之后，也能够支持分析MIPS架构的漏洞了。然而，其误报率非常之高，笔者在使用了之后，发现该工具报告的漏洞基本都不可用。因此，如何基于上述符号执行的思想，结合IDA工具中强大的反汇编能力，开发也具有符号执行功能的MIPS架构漏洞分析工具，相信也是非常有价值的。由于时间仓促，笔者对于一些部分的理解难免有误，望各位读者见谅以及不吝赐教。感谢。"}]}]}